<!DOCTYPE html>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<html>
  <head>
    <title>Knowledge Graph Query and Display</title>
    <script src="external/d3.v7.min.js"></script>
    <script src="external/cytoscape.min.js"></script>

    <script src="external/dagre.js"></script>
    <script src="external/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2/dist/umd/popper.js"></script>
    <script src="external/cytoscape-popper/cytoscape-popper.js"></script>
    <script src="external/cytoscape-context-menus/cytoscape-context-menus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/copy-image-clipboard/dist/index.browser.js"></script>
    <script src="external/cytoscape-expand-collapse.js"></script>
    <script src="external/cytoscape.js-navigator-master/cytoscape-navigator.js"></script>
    <script src="https://unpkg.com/webcola/WebCola/cola.min.js"></script>
    <script src="external/cytoscape-cola/cytoscape-cola.js"></script>
   

    <link rel="stylesheet" href="external/cytoscape.js-navigator-master/cytoscape.js-navigator.css">
    <style type="text/css">
      .body{
        margin: 0;
      }

      #cy {
        display: none;
        height: 67vh;
        margin-top:30px;
        width: 100%;
        border-style: solid;
      }


      #navigation-history{
        max-width: 100%;
        display: inline-block;
      }
 
      .title {
        text-align: center;
      }
      
      #nav-up,
      #nav-down,
      #nav-left,
      #nav-right{
        border-radius: 50px;
        background-color: white;
        font-weight: 600;
        width: 140px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }

      #middle-nav{
        border-radius: 50px;
        background-color: #f08080;
        border: 0px;
        font-weight: 600;
        width: 130px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }
  

      .btn {
        background-color: black;
        color: white;
        padding: 10px;
        width: 100px;
      }



      .btn2 {
        background-color: green;
        color: white;
        padding: 10px;
        width: 100px;
      }

      #Collapse {
        background-color: grey;
        visibility: hidden;
      }

      .input-species {
        background-color: white;
        color: black;
        margin-top: 20px;
        margin-bottom: 20px;
        margin-right: 5px; 
        height: 20px;
        width: 150px;
      }

      .hierarchy-entry-button {
        background-color: white;
        margin-top: 20px;
        margin-bottom: 20px;
        width: 100px; 
        height: 30px;
      }

      .nav-history{
        display: flex;
      }
      
      /* CONTEXT MENUS */
      .cy-context-menus-cxt-menu {
          display:none;
          z-index: 1000;
          position:absolute;
          border:1px solid #A0A0A0;
          padding: 0;
          margin: 0;
          width:auto;
      }

      .cy-context-menus-cxt-menuitem {
          display:block;
          width: 100%;
          padding: 3px 20px;
          position:relative;
          margin:0;
          background-color:#f8f8f8;
          font-weight:normal;
          font-size: 12px;
          white-space:nowrap;
          border: 0;
          text-align: left;
      }

      .cy-context-menus-cxt-menuitem:enabled {
          color: #000000;
      }

      .cy-context-menus-ctx-operation:focus {
        outline: none;
      }

      .cy-context-menus-cxt-menuitem:hover {
          color: #ffffff;
          text-decoration: none;
          background-color: #fdd3ef;
          background-image: none;
          cursor: pointer;
      }

      .cy-context-menus-cxt-menuitem[content]:before {
          content:attr(content);
      }

      .cy-context-menus-divider {
        border-bottom:1px solid #A0A0A0;
      }

      .cy-context-menus-submenu-indicator {
          position: absolute;
          right: 2px;
          top: 50%;
          transform: translateY(-50%);
      }

      
    </style>

    <script> 
      // Early definitions: used throughout the code
      let my_result;
      let bindings;
      let len;
      let nodes, child, parent;
      let data_obj;
      let qvals_to_names = {};
      let names_to_qvals = {};
      let ranks_to_properties = {};
      var contextMenu;
      var nested = [] // Array to track whether an event listener has been made 

      const ROOT_QVAL = "Q729";
      const ROOT_NAME = "Animalia";

      // For return to normal
      var rank_removal;
      var rank_removed = false;
      // Implement dictionary to keep track of positioning. Fisheye is unreliable
      var positions = {};
      // Selectors that are removed at the default state. Unsure how to remove expand collapse properties, so I'm doing it manually now 
      var to_remove = [`node[type = "subTaxProp"]`, `node[type = "overlay hierarchy"]`, `node[type = "display"]`, `node[class = "property"]`, `node[class = "property-edge"]`, `node[type = "concept"]`, `node[type = "literal"]`, `node[type = "property definition"]`, `node[type = "bnode"]`, `node[type = "image"]`, `node[width = 120]`];
      var expand_collapse_properties = ['collapse', 'expandcollapseRenderedCueSize', 'expandcollapseRenderedStartX', 'expandcollapseRenderedStartY', 'position-before-collapse', 'size-before-collapse'];

      var arrows = {};

      const prefixes = {
        "http://solid.boltz.cs.cmu.edu:3030/data/": "boltz:",
        "http://solid.boltz.cs.cmu.edu:3030/ontology/": 'kgo:',
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#": 'rdf:',
        "http://www.w3.org/2000/01/rdf-schema#": 'rdfs:',
        "http://www.w3.org/2002/07/owl#": 'owl:',
        "http://www.w3.org/2004/02/skos/core#": 'skos:',
        "http://qudt.org/schema/qudt/": 'qudt:',
        "http://qudt.org/vocab/unit/": 'unit:',
        "http://qudt.org/vocab/dimensionvector/": 'qkdv:',
        "http://qudt.org/vocab/sou/": 'sou:',
      };

    //takes a string and capitalizes all first letters of the word;
    function capitalize(str) {
        return str.charAt(0).toUpperCase() + (str.toLowerCase()).slice(1);;
    }


    function hierarchy_query(taxon_value, perform_query) {
        const prevquery = document.getElementById("sparql");
        prevquery.innerHTML = 
          `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
           PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
           PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
           PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
           PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
           PREFIX qudt:  <http://qudt.org/schema/qudt/>
           PREFIX unit:  <http://qudt.org/vocab/unit/> 
           PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
           PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
           PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
           PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
           PREFIX la: <https://linked.art/ns/terms/>
           PREFIX un: <http://www.w3.org/2007/ont/unit#> 
           PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
           SELECT DISTINCT ?root_name ?root ?root_rank ?parent_name ?parent ?parent_prefLabel
           ?child_name ?child ?child_prefLabel ?def ?root_def ?rank ?rank_name
             WHERE { 
               BIND ("${taxon_value}"@en AS ?root_name). 
                 ?root kgo:taxonName ?root_name .  
                 ?root kgo:taxonRank [rdfs:label ?root_rank] .
                 OPTIONAL {
                   ?root skos:definition ?root_def .
                 }
                 ?child kgo:subTaxonOf* ?root . 
                 ?child kgo:subTaxonOf ?parent . 
                 ?child kgo:taxonName ?child_name .
                 OPTIONAL {
                   ?child skos:definition ?def .
                 }
                   ?child kgo:taxonRank ?rank .
                   ?rank rdfs:label ?rank_name . 
                   ?parent kgo:taxonName ?parent_name .
                   ?child skos:prefLabel ?child_prefLabel .
                   ?parent skos:prefLabel ?parent_prefLabel .
             }`

        if (perform_query) {
          const endpoint = d3.select("#endpoint").property("value")
          const sparql = d3.select("#sparql").property("value")
          const url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        } else {
          return false
        }
    }

    function property_query(taxon_value, perform_query) {
      const prevquery = document.getElementById("sparql2");
      prevquery.innerHTML = 
        `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
         PREFIX dc: <http://purl.org/dc/elements/1.1/> 
         PREFIX dcterms: <http://purl.org/dc/terms/>
         PREFIX owl: <http://www.w3.org/2002/07/owl#>
         PREFIX prefix: <http://qudt.org/vocab/prefix/>
         PREFIX prov: <http://www.w3.org/ns/prov#> 
         PREFIX qkdv: <http://qudt.org/vocab/dimensionvector/> 
         PREFIX quantitykind: <http://qudt.org/vocab/quantitykind/> 
         PREFIX sou: <http://qudt.org/vocab/sou/> 
         PREFIX vaem: <http://www.linkedmodel.org/schema/vaem#> 
         PREFIX voag: <http://voag.linkedmodel.org/schema/voag#>
         PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
         PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
         PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
         PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
         PREFIX qudt:  <http://qudt.org/schema/qudt/>
         PREFIX unit:  <http://qudt.org/vocab/unit/> 
         PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
         PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
         PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
         PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
         PREFIX la: <https://linked.art/ns/terms/>
         PREFIX un: <http://www.w3.org/2007/ont/unit#> 
         PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
         SELECT DISTINCT ?pred ?predLabel ?obj ?objLabel ?pred2 ?pred2Label ?list ?obj2 ?obj2Label
           WHERE {
             BIND ( '${taxon_value}' @en AS ?name).
              ?Q skos:prefLabel|kgo:taxonName ?name.
              ?Q ?pred ?obj. 
              OPTIONAL {?Q ?pred [ list:index (?pos ?list) ] }
              OPTIONAL {?Q ?pred ?obj.
                        ?obj ?pred2 ?obj2.
                        OPTIONAL {?pred2 rdfs:label ?pred2Label.}
                        OPTIONAL {?obj2 rdfs:label ?obj2Label.}
                      }
              OPTIONAL { ?pred skos:prefLabel|rdfs:label ?predLabel. } 
              OPTIONAL { ?obj kgo:taxonName|skos:prefLabel|rdfs:label ?objLabel. }
           } ORDER BY ?pred ?pos ?pred2`; 

        
        if (perform_query) {
          const endpoint = d3.select("#endpoint2").property("value")
          const sparql = d3.select("#sparql2").property("value")
          const url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        } else {
          return false
        }

    }

    function box_node_query(taxon_value, perform_query) {
      const prevquery = document.getElementById("sparql3");
      prevquery.innerHTML = 
        `PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
         PREFIX unit:  <http://qudt.org/vocab/unit/>
         PREFIX qudt:  <http://qudt.org/schema/qudt/>
         PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
         PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
         PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
         
         SELECT * WHERE {
          ?taxon kgo:taxonName "${taxon_value}"@en .
          ?taxon ?r ?b.
          ?b rdf:type rdf:List;
             rdf:rest* ?b2.
          ?b2 ?r2 ?v2.
          OPTIONAL { ?v2 skos:prefLabel|rdfs:label ?v2Label. } 
          OPTIONAL { ?r2 skos:prefLabel|rdfs:label ?r2Label. } 

        }`
        if (perform_query) {
          const endpoint = d3.select("#endpoint3").property("value")
          const sparql = d3.select("#sparql3").property("value")
          const url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        } else {
          return false
        }
    }


    function rank_property_query(rank_name) {
      const prevquery = document.getElementById("sparql4");
      prevquery.innerHTML = 
        `PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
         PREFIX rdfs:  <http://www.w3.org/2000/01/rdf-schema#> 
         PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
         SELECT DISTINCT ?rank ?rLabel ?nextLower ?nextHigher
          WHERE {
            ?rank rdfs:label "${rank_name}"@en .
            ?rank rdfs:label ?rLabel .
            ?rank kgo:nextLowerRank [ rdfs:label ?nextLower] . 
            ?rank kgo:nextHigherRank [ rdfs:label ?nextHigher ].
              
          }
        ORDER BY ?yLabel`;

      const endpoint = d3.select("#endpoint4").property("value");
      const sparql = d3.select("#sparql4").property("value");
      const url = endpoint + "?query=" + encodeURIComponent(sparql);
      return url;
        
    }

    // Obtain all ranks in the system, to be displayed in a new window
/*      function all_ranks_query(){
      const prevquery = document.getElementById("sparql5");
      prevquery.innerHTML = 
        `PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 

          SELECT ?rank ?rankLabel ?definition ?nextHigher ?nextLower WHERE {
            ?rank kgo:instanceOf boltz:Q427626 ;
                  rdfs:label ?rankLabel ;
                  skos:definition ?definition .
            OPTIONAL{?rank kgo:nextHigherRank ?nextHigher}.
            OPTIONAL{?rank kgo:nextLowerRank ?nextLower}.
          } `;

      const endpoint = d3.select("#endpoint5").property("value");
      const sparql = d3.select("#sparql5").property("value");
      const url = endpoint + "?query=" + encodeURIComponent(sparql);
      return url;
    } */

    function all_ranks_query(rank_name){
      const prevquery = document.getElementById("sparql5");
      prevquery.innerHTML = 
        `PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 

          SELECT ?rank ?rankLabel ?definition ?nextHigher ?nextLower WHERE {
            ?currRank rdfs:label "${rank_name}"@en .
            ?rank kgo:instanceOf boltz:Q427626 ;
                  rdfs:label ?rankLabel ;
                  (kgo:nextHigherRank|kgo:nextLowerRank)? ?currRank ;
                  skos:definition ?definition .
            OPTIONAL{
              ?rank kgo:nextHigherRank ?nextHigher .
            }
            OPTIONAL{
              ?rank kgo:nextLowerRank ?nextLower .
            }
          } `;

      const endpoint = d3.select("#endpoint5").property("value");
      const sparql = d3.select("#sparql5").property("value");
      const url = endpoint + "?query=" + encodeURIComponent(sparql);
      return url;
    }

    function all_properties(node_qval) {
      const prevquery = document.getElementById("sparql6");
      prevquery.innerHTML = 
        `PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
          PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
          PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
          PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
          PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

          SELECT ?x ?y ?xLabel ?yLabel WHERE {
            BIND (boltz:${node_qval} AS ?r) .
            ?r ?x ?y .
            OPTIONAL {?x rdfs:label ?xLabel} .
            OPTIONAL {?y rdfs:label ?yLabel} .
          }`;

      const endpoint = d3.select("#endpoint6").property("value");
      const sparql = d3.select("#sparql6").property("value");
      const url = endpoint + "?query=" + encodeURIComponent(sparql);
      return url;
    }

    /*convert_to_cytoscape will return an object
    that stores the nodes, the edges, the positions of all
    the nodes, and the ranks for each of the nodes*/
    function convert_to_cytoscape(data) {
        let nodes_lst = [];
        let edges_lst = [];
        let rank_node_edges = {}; //consists of objects that have ranks and nodes that are connected by an edge
        let pc_edges = {};
        let root = 'noRoot';
        let root_rank = "noRank";
        let def_for_taxons = {};
        let node_names = [];

        let qvals_to_names = {};
        let names_to_qvals = {};
        let root_def = "No def";
        let pref_labels = {}; //key is preflable and value is taxon_name
        //need to make edge object based on qvalues and not names

        let parent_and_all_children = {} 
        //going to be an object where the keys are parents and the values are a list of all children

        
        bindings = data.results.bindings;
        len = bindings.length;

        if (len > 0) {
          //we can assume that the first parent is the root for now?
            if (bindings [0].parent_name != undefined &&
                bindings [0].root_rank != undefined &&
                bindings [0].root_def != undefined) {
                  root = bindings [0].parent_name.value;
                  root_rank = bindings [0].root_rank.value;
                  root_def = bindings [0].root_def.value;
                }

                root_qval = bindings [0].parent.value;
                if (root_qval.length >= 40) {
                  root_qval = root_qval.slice(40, root_qval.length);
                }
                names_to_qvals[root] = root_qval
                def_for_taxons[root_qval] = root_def;
                qvals_to_names[root_qval] = root;
            
        }

        /*first we can grab all of the values in our returned json result
        and add them as nodes in alphabetical order. 
        */
        /*so we'll iterate through our json object and
        grab the node names and sort them
        */
        
        
        let root_prefLabel;

        if (root_prefLabel != undefined) {
              let root_prefLabel = capitalize(root_prefLabel);
              if (pref_labels[root_prefLabel] == undefined) {
                pref_labels[root_prefLabel] = root;
              }
        }

        node_names.push({name: root, qval: root_qval});

        for (key_object in bindings) {
            object = bindings[key_object]
            child_rank = object.rank_name.value;
            child_def = object.def.value;
            child_qval = object.child.value;
            parent_qval = object.parent.value;
            child_prefLabel = object.child_prefLabel.value;
            parent_prefLabel = object.parent_prefLabel.value;
            parent = object.parent_name.value;
            rank_qval = object.rank.value;
            rank = object.rank_name.value;
            child = object.child_name.value;

            // Update dictionary
            qvals_to_names[rank_qval] = rank;

            //ignore the data if the parent and child qvals are the same

            if (child_qval.length >= 40 && parent_qval.length >= 40) {
              child_qval = child_qval.slice(40, child_qval.length);
              parent_qval = parent_qval.slice(40, parent_qval.length);
            }

            if (child_qval == root_qval) {
              let root_prefLabel = capitalize(child_prefLabel);
              if (pref_labels[root_prefLabel] == undefined) {
                pref_labels[root_prefLabel] = root;
              }
            }
            if (parent_qval == root_qval) {
              let root_prefLabel = capitalize(parent_prefLabel);
              if (pref_labels[root_prefLabel] == undefined) {
                pref_labels[root_prefLabel] = root;
              }
            }

            //only want to continue if parent and child qvals are diff and if 
            //we haven't seen the child yet
            if (child_qval != parent_qval && qvals_to_names[child_qval] == undefined) {
              node_names.push({name: child, qval: child_qval});

              def_for_taxons[child_qval] = child_def;
              qvals_to_names[child_qval] = child;

              if (names_to_qvals[child] != undefined) {
                names_to_qvals[`${child}: ${rank}`] = child_qval;
              } else {
                names_to_qvals[child] = child_qval;
              }
              //because the child name can be repeated


              if (child_prefLabel != undefined) {
                child_prefLabel = capitalize(child_prefLabel);
                if (pref_labels[child_prefLabel] == undefined) {
                  pref_labels[child_prefLabel] = child;
                }
              }
              pc_edges[child_qval] = parent_qval; //source is the key and target is the value
              rank_node_edges[child_qval] = rank;       
            }

        }
        node_names = node_names.sort(function(a, b) {
            let keyA = a.name;
            let keyB = b.name;
            // Compare the 2 dates
            let result = keyA.localeCompare(keyB);
            return result;
          });
        

        for (let idx = 0; idx < node_names.length; idx++) {
          curr_name = node_names[idx].name;
          curr_qval = node_names[idx].qval;
         
          node_obj = {
              data: {id: curr_qval, 
              name:`${curr_name} boltz: ${curr_qval.toString()}`,
              color: '#ADD8E6', 
              width: 250, 
              height: 250,
              type: 'taxon'
            }};
            nodes_lst.push(node_obj);



          if (curr_name != ROOT_NAME) {
            parent_qval = pc_edges[curr_qval];
            parent_name = qvals_to_names[parent_qval];

            if (curr_qval != undefined && parent_qval != undefined) {

                    rank = rank_node_edges[curr_qval];
                    if (parent_and_all_children[parent_qval] == undefined) {
                        parent_and_all_children[parent_qval] = [curr_qval];
                    } else {
                      parent_and_all_children[parent_qval].push(curr_qval);
                    }
                            

                  pc_edge = {data: {id: `${curr_qval} - ${parent_qval}`, 
                      source: curr_qval, target: parent_qval, label:'subTaxonOf'}};
                    
                    edges_lst.push(pc_edge); 

                      
                    
            }
            
          }

        }



        pc_edges[root_qval] = 'root';
        rank_node_edges[root_qval] = root_rank;


        return {nodes: nodes_lst, edges: edges_lst, 
          rn_edges: rank_node_edges, pc_edges: pc_edges, 
          root_rank: root_rank, root: root_qval, definitions: def_for_taxons, 
          taxon_qvals: qvals_to_names, pref_labels: pref_labels, 
          names_to_qvals:names_to_qvals, parent_and_all_children: parent_and_all_children};
    }



    //graphType letiable is used to keep track of if the Full or Concise button was pressed

    function find_new_target(old_target, rn_edges, pc_edges, correct_ranks, user_entered_taxon) {
        //pc_edges is an object where the sources are keys and the values are the targets
        let curr_source = old_target;
        let curr_target = pc_edges[curr_source];
        let is_valid_rank = correct_ranks.includes(rn_edges[curr_target]);

        while (!is_valid_rank && curr_target != user_entered_taxon && curr_target != undefined) {

           curr_source = curr_target; //idea is to keep "climbing up" this tree
           //assumption is that curr_source is never going to be undefined
          
           curr_target = pc_edges[curr_source];
           is_valid_rank = correct_ranks.includes(rn_edges[curr_target]);
        }

        if (curr_target == undefined){
          curr_target = ROOT_QVAL //if for some reason we can't find a target then we can just
          //assign the target to the root for now
        }

        return curr_target;
    }
    
    /*so we're given the original nodes and edges and we want to output new nodes/edges
    such that there are only nodes with ranks: correct_ranks.
    if a user enters a taxon in the textbox we automatically want to keep this value
    all missing edges are filled in, also will want to return the rn_edges */
    function create_graphType(data, correct_ranks, user_entered_taxon) {

        let nodes = data.nodes;
        let edges = data.edges;
        let rn_edges = data.rn_edges;
        let pc_edges = data.pc_edges;  //keys are sources and values are targets
        let root = data.root;
        
        let new_edges = [];
        let new_nodes = [];
        let edges_missing = {}; //keeps track of the nodes that now no longer have edges because of the removed ranks
        let taxon_qvals = data.taxon_qvals;

        let graphType_pc_edges = {};
        let node_names = [];  
        let graphType_parent_and_all_children = {};
        let tracking_node_qvals = {};

        //iterating through all the edges and figuring out which ones are going to be removed 
        for (let i = 0; i < edges.length; i++) {

              curr_edge = edges[i];  //of the form: {id: __, source: '', target: '', ...}
              source_node = curr_edge.data.source; //qval
              target_node = curr_edge.data.target; //qval
              keep_source = correct_ranks.includes(rn_edges[source_node]);
              keep_target = correct_ranks.includes(rn_edges[target_node]);
              
              //taking care of the case when a user enters a taxon into the text box
              if (source_node == user_entered_taxon) {
                keep_source = true;
              }
              else if (target_node == user_entered_taxon) {
                keep_target = true;
              }

              if (keep_source && tracking_node_qvals[source_node] == undefined) {
                node_names.push({name: taxon_qvals[source_node], qval: source_node});
                tracking_node_qvals[source_node] = "yes";
                //node_names.push(source_node);
              }
              if (keep_target && tracking_node_qvals[target_node] == undefined) {
                node_names.push({name: taxon_qvals[target_node], qval: target_node});
                tracking_node_qvals[target_node] = "yes";
                //node_names.push(target_node);
              }

              if (!keep_source && !keep_target) {
                  //this means both the target and the source node aren't going to be added
                  let count = "pass";

              } else if (!keep_source || !keep_target)  {
                  //adding missing: "target" regardless, b/c that's what we want to prioritize
                  //and only adding missing: "source" if the em object doesn't already have something there
                              if (!keep_source) {
                                //target_node is valid source_node is going to be removed
                              
                                if (edges_missing[target_node] == undefined) {
                                    new_obj = {
                                        missing: "source",
                                        old_edge: curr_edge,       
                                    };
                                    edges_missing[target_node] = new_obj;
                                    //we know source_node is attached to a valid rank from else clause
                                }
                                  
                              }

                              if (!keep_target) {
                                  new_obj = {
                                      missing: "target",                
                                      old_edge: curr_edge               
                                  };
                                  edges_missing[source_node] = new_obj;
                              }

              } else {
                //we are keeping both the source and target nodes so the original edge
                graphType_pc_edges[source_node] = target_node;
              }

         }
        //at this point don't really need to add anymore nodes
        for (node in edges_missing) {
            curr_data = edges_missing[node]  ;
            //of the form {missing: "source/target", old_edge: {id: , source:, target: }}

            //don't need to worry about curr_data.missing source 
            
            if (curr_data.missing == 'target') {
                old_target = curr_data.old_edge.data.target; //qval
                curr_source = curr_data.old_edge.data.source; //qval
                //now we want to find a new target
                new_target = find_new_target(old_target, 
                rn_edges, pc_edges, correct_ranks, user_entered_taxon);

                graphType_pc_edges[curr_source] = new_target;
            }
        }
        //sort the node names in alphabetical order
        
        node_names = node_names.sort(function(a, b) {
            let keyA = a.name;
            let keyB = b.name;
            // Compare the 2 node names
            let result = keyA.localeCompare(keyB);
            return result;
          });
        
        //this will be used to keep track of the qvals we see to 
        //make sure we aren't adding multiple instances of the same node
        
        //let tracking_target_qvals = []
        //should now be sorted in alphabetical order
        for (let i = 0; i < node_names.length; i++) {
              source_node_qval = node_names[i].qval;
              source_node_name = node_names[i].name;
              target_node_qval = graphType_pc_edges[source_node_qval];
              target_node_name = taxon_qvals[target_node_qval];
              if (source_node_qval != `${root}`) {
                source_node_name = `${source_node_name} boltz:${source_node_qval}`;
                target_node_name = `${target_node_name} boltz:${target_node_qval}`;
                
                let node_width;
                let node_height;

                if (source_node_qval[0] != `Q`) {
                   node_width = 0;
                   node_height = 0;
                } else {
                   node_width = 250;
                   node_height = 250;
                }
                //need this because we are only adding the source nodes because the target
                //nodes will eventually be taken care of except for Animalia which doesn't have a target node
                new_nodes.push({
                  data: {
                    id: source_node_qval, 
                    name: source_node_name, 
                    color: '#ADD8E6', 
                    width: node_width, 
                    height: node_height,
                    type: 'taxon'
                }});
                if (target_node_qval == `${root}`) { //Q2382443 is the Biota Qval
                  new_nodes.push({
                      data: {
                        id: target_node_qval, 
                        name: target_node_name, 
                        color: '#ADD8E6', 
                        width: 250, 
                        height: 250,
                        type: 'taxon'
                      }});
                }
                if (source_node_qval != undefined && target_node_qval != undefined) {
                    
                    if (graphType_parent_and_all_children[target_node_qval] == undefined) {
                      graphType_parent_and_all_children[target_node_qval] = [source_node_qval];
                    } else {
                      if (!graphType_parent_and_all_children[target_node_qval].includes(source_node_qval) ) {
                        graphType_parent_and_all_children[target_node_qval].push(source_node_qval);
                      }
                    }

                    new_edge = {data: {id: `${source_node_qval} - ${target_node_qval}`, 
                    source: source_node_qval, target: target_node_qval, label:'subTaxonOf'}};
                    new_edges.push(new_edge);
                }
              }
              

        }

      
        return {nodes: new_nodes, 
                edges: new_edges, 
                em: edges_missing,
                newPC_edges: graphType_pc_edges,
                graphType_parent_and_all_children: graphType_parent_and_all_children};


    }
      //when a specific node is clicked,i.e. node_name
      //all other nodes and edges become transparent
      function shade_other_nodes(node_qval, id_lastclicked_node) {
          cy.elements().nodes().style( { 'opacity' : '.2', 'text-opacity':0 });

          
          if (id_lastclicked_node != "") {
              cy.$id(id_lastclicked_node).style({
                "background-color": "#ADD8E6",
                'border-width': 0
              });
            };
          
          cy.elements().edges().style( { 'line-opacity' : '.2', 'text-opacity':'0' });
    
          cy.$id(node_qval).style({
            'border-color': '#FFB6C1',
            'text-opacity': '1',
            'opacity': '1',
            'text-wrap': 'wrap',
            'text-max-width': 125,
            'border-width': 5,
            'border-style': 'solid',
            'font-size': 30,
            'font-family': 'Calibri',
            'line-height': 1.15
          });
          
      }




      // Takes in an array of objects from a property query and outputs a new array that eliminates redundancy
      function trim_prop_query(property_array) {
        // We are going to be looking for a repeat of objLabel and predLabel
        let pred_labels = [];
        let new_property_array = [];
        let obj_label;
        let curr_data_val;
        let bnode_num;
        let bnode_obj;
        let obj2_value;

        // Also don't want to count a bnode as multiple nodes
        let bnodes = {};
        let bnode_obj_values = [];
        let curr_bnode_num = 'b0';
        let subtax_rank = {};

        subtax_rank['subtax_identifier'] = "";
        

        for (let i = 0; i < property_array.length; i++) {
            curr_data_val = property_array[i];
            // First check if we have a bnode, if we do automatically add it to our array
            if (curr_data_val.obj != undefined &&
                curr_data_val.obj.type == 'bnode') {
                    
                    bnode_num = curr_data_val.obj.value;
                    if (bnode_num != curr_bnode_num) {
                      // We are now at a diff bnode_num so reset bnode_obj_values; purpose of this is to avoid repeated data in the bnode_objs that are going to be returned
                      bnode_obj_values = [];
                      curr_bnode_num = bnode_num;
                    }

                    bnode_obj = {};

                    if (curr_data_val.pred2 != undefined 
                      && curr_data_val.obj2 != undefined) {
                            
                            // First need to check that this node_value isn't already added
                            obj2_value = curr_data_val.obj2.value;
                            if (!(bnode_obj_values.includes(obj2_value))) {
                                  bnode_obj = {pred2: curr_data_val.pred2.value,
                                  obj2: obj2_value,
                                  pred2Label: curr_data_val.pred2Label,
                                  obj2Label: curr_data_val.obj2Label};

                                  if (bnodes[bnode_num] == undefined) {
                                    bnodes[bnode_num] = [bnode_obj];
                                    new_property_array.push(curr_data_val);
                                  } else {
                                    bnodes[bnode_num].push(bnode_obj);
                                  }

                                  bnode_obj_values.push(obj2_value);

                            }
                            
                    }      

            }
            
            else if (curr_data_val.objLabel != undefined && curr_data_val.predLabel != undefined) {
              

                obj_label = curr_data_val.objLabel.value;
                pred_label = curr_data_val.predLabel.value;

                if (!(pred_labels.includes(pred_label))) {

                    if (curr_data_val.predLabel != undefined) {
                      if (curr_data_val.predLabel.value == 'subTaxonOf' && subtax_rank['subtax_identifier'] == "") {

                        subtax_rank['subTaxonOf'] = obj_label;

                        let qval_url = curr_data_val.obj.value;
                        if (qval_url.length >= 40
                            && (qval_url.slice(0, 40)) == 'http://solid.boltz.cs.cmu.edu:3030/data/') {
                            subtax_name = `${obj_label}    boltz: ${qval_url.slice(40, qval_url.length)}`;
                            subtax_rank['subtax_identifier'] = subtax_name;
                        }
                      }
                      else if (curr_data_val.predLabel.value == 'taxonRank') {
                        subtax_rank['taxonRank'] = obj_label;

                      } else {
                        new_property_array.push(curr_data_val);
                      }
                      
                    }
                }
                pred_labels.push(pred_label);

            } else {
              new_property_array.push(curr_data_val);
            }

        }

        return {prop_array: new_property_array, bnodes_obj: bnodes, subtax_rank: subtax_rank};
        

      }
      
      //takes care of the functionality after clicking the b4 node
      function add_b5_node(b4_node_id, b4_node_pos, rest_of_prefs, diam) {
          let b4_x = b4_node_pos.x;
          let b4_y = b4_node_pos.y;
          let first_node_id = 'b4 first prop';
          let b5_node_id = 'b5';
          let b5_x = b4_x - 175
          let b5_y = b4_y - 150
          //let first_comp = rest_of_prefs.shift();
          let first_comp = rest_of_prefs[0];
          let first_node = 
            {
              group: 'nodes',
              data: {
                id: first_node_id,
                color: '#FFD580',
                name: first_comp,
                opacity: 1,
                width: diam,
                height: diam,
                type: `b4 property`
              },
              position: {x: b4_x - 175, y: b4_y + 150}
            };
          cy.add([first_node]);
          let new_edge = 
            {
              group: 'edges',
              data: 
                  {
                    id: b4_node_id.concat(first_node_id),
                    source: b4_node_id, 
                    target: first_node_id,
                    label: 'first'
                  }
                };
          cy.add([new_edge]);
          
          //let b5_node_name = `b5: [${rest_of_prefs.shift()}]`;
          let last_val = rest_of_prefs[1]
          let b5_node_name = `b5: [${last_val}]`;

          let b5_node = 
            {
                group: 'nodes',
                data: {
                  id: b5_node_id,
                  color: '#FFD580',
                  name: b5_node_name,
                  opacity: 1,
                  width: diam,
                  height: diam,
                  type: `b4 property`
                },
                position: {x: b5_x, y: b5_y}
            };
          cy.add([b5_node]);
          new_edge = 
            {
              group: 'edges',
              data: 
                {
                  id: b4_node_id.concat(b5_node_id),
                  source: b4_node_id, 
                  target: b5_node_id,
                  label: 'rest'
                }
              };
          cy.add([new_edge]);
          let id_selector = `node[type = 'b4 property']`;
              cy.nodes(id_selector).style({
                'background-color': '#CBC3E3',
                'text-wrap': 'wrap',
                'text-max-width': diam - 10,
                'border-width': 3,
                'border-color': '#301934',
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              });
              cy.elements().edges().style({'font-size': '30'});

          let id_label = `[id = '${b5_node_id}']`;
          let parity_of_tap = 'even'
          cy.nodes(id_label).on('click', function(evt) {

              let data = evt.target.data();
              if (parity_of_tap == 'even') {
                cy.add([
                  {group: 'nodes', data: {id: 'b5 first prop', color:'#FFD580',
                  name: last_val, width: diam, height: diam, type: 'b5 property'},
                  position: {x: b5_x -175, y: b5_y + 175}}]);
                cy.add([
                  {group: 'nodes', data: {id: 'empty list', color:'#FFD580',
                  name: '[]', width: diam, height: diam, type: 'b5 property'},
                  position: {x: b5_x -175, y: b5_y - 175}}]);
                cy.add([
                  {group: 'edges',data: {
                              id: b5_node_id.concat('b5 first prop'),
                              source: b5_node_id, 
                              target: 'b5 first prop',
                              label: 'first'
                          }}
                        ]);
                cy.add([
                  {group: 'edges',data: {
                      id: b5_node_id.concat('empty list'),
                      source: b5_node_id, 
                      target: 'empty list',
                      label: 'rest'
                  }}
                ]);
              let id_selector = `node[type = "b5 property"]`;
              cy.nodes(id_selector).style({
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': diam - 10,
                      'border-width': 3,
                      'border-color': '#301934',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
              });
                cy.elements().edges().style({'font-size': '30'});
                parity_of_tap = 'odd';
                cy.nodes(`[id = "${data.id}"]`).style(
                  {'label': 'b5',
                  'shape': 'hexagon',
                  'background-color': '	#fdfa72',
                  'border-color': '#F6BE00'
                                      
                  });

              } else {

                cy.remove('node[type = "b5 property"]');
                
                cy.nodes(`[id = "${data.id}"]`).style({
                  'label': `b5: [${last_val}]`,
                  'shape': 'ellipse',
                  'background-color': '	#CBC3E3',
                  'border-color': '#301934',
                  'border-style': 'solid'
                });
                parity_of_tap = 'even';
              }
          })

      }


      //box_nodes is just the data of the node
      //bnode_properties is thee object with a list of property nodes
      //bnode_name is going to be the name of the bnode
      function add_values_to_bnode(bnode_name, box_nodes, bnode_properties, 
             padding_amt, taxon_x_pos, taxon_y_pos, b4node_names) {
              
              let diam = 120;
              let bnode_data = box_nodes[bnode_name];
              let bnode_pos = bnode_data.position;
              let x_pos = bnode_pos.x;
              let y_pos = bnode_pos.y;
              

              let old_radius = Math.sqrt(Math.pow(taxon_x_pos - x_pos, 2) 
                                          + Math.pow(taxon_y_pos - y_pos, 2));
             
              let x_dist = taxon_x_pos - x_pos;  //need to do this to pretend that taxon is at an origin

              let bnode_degree = Math.acos(x_dist/old_radius);
              if (taxon_y_pos > y_pos && bnode_degree <= (.5 * Math.PI)) {
                bnode_degree = (-1 * bnode_degree) + 2* Math.PI;
              }
              //bnode_degree is the degree that the bnode forms with the taxon_value
              
              let added_els = [];

              let num_bnode_props = bnode_properties[bnode_name].length;
              let mult_constant =5;

              let circumference = (num_bnode_props) * diam;
              let radius = circumference / (2* Math.PI);
              let curr_degree = bnode_degree;
              let degree_movement = (2 * Math.PI) / (num_bnode_props);
              //+1 because we want to count the edge as another 'piece'

              let bnode_vals = [];

              let curr_bnode_props = bnode_properties[bnode_name];
              let add_b5 = false;

              for (let i = 0; i < num_bnode_props; i++) {

                    if (i == 0) {
                      new_degree = (curr_degree + (degree_movement/2))% (Math.PI *2);
                    } else {
                      new_degree = (curr_degree + (degree_movement))% (Math.PI *2);
                    }
                    let next_x_pos = x_pos + (radius*mult_constant)*(Math.cos(new_degree));
                    let next_y_pos = y_pos - (radius*mult_constant)*(Math.sin(new_degree));
                    let curr_degree = new_degree;

                    let curr_bnode_prop = curr_bnode_props[i].obj2;
                    let curr_edge_label = curr_bnode_props[i].pred2;

                    if (curr_bnode_props[i].pred2Label != undefined) {
                      curr_edge_label = curr_bnode_props[i].pred2Label.value;
                    }
                    if (curr_bnode_props[i].obj2Label != undefined) {
                      curr_bnode_prop = curr_bnode_props[i].obj2Label.value;
                    }

                    if (curr_bnode_prop == 'b4') {
                      rest_list = b4node_names.full_list.slice(1, b4node_names.full_list.length);
                      curr_bnode_prop = `b4: [${rest_list.join(', ')}]`;
                      add_b5 = true;
                      let b4_node_id = `${curr_bnode_prop} - ${bnode_name}`
                      //so only want to add an onclick function 
                    }
                    let node_id = `${curr_bnode_prop} - ${bnode_name}`;
                    if (curr_bnode_prop != undefined) {  
                      let new_property_node = 
                                {
                                    group: 'nodes',
                                    data: {
                                      id: node_id,
                                      color: '#FFD580',
                                      name: curr_bnode_prop,
                                      opacity: 1,
                                      width: diam,
                                      height: diam,
                                      type: `${bnode_name} property`
                                    },
                                    position: {x: next_x_pos, y: next_y_pos}
                                };       
                        added_els.push(new_property_node);
                        let new_edge = 
                                {
                                  group: 'edges',
                                  data: 
                                      {
                                          id: node_id.concat(bnode_name),
                                          source: bnode_name, 
                                          target: node_id,
                                          label: curr_edge_label
                                      }
                                };

                          added_els.push(new_edge);
                        }
              }

              cy.add(added_els);
              let id_selector = `node[width = ${diam}]`;
              cy.nodes(id_selector).style({
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': diam - 10,
                      'border-width': 3,
                      'border-color': '#301934',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
              });
              cy.elements().edges().style({'font-size': '30'});

              if (add_b5) {
                let id_label = `[id = "${b4_node_id}"]`;
                let parity_of_tap = 'even';
                let len = b4node_names.full_list.length;
                let rest_names = b4node_names.full_list.slice(1,len).join(', ');
                cy.nodes(id_label).on('click', function(evt) {
                      let data = evt.target.data();
                      let pos = evt.target.position();
                      if (parity_of_tap == 'even') {
                        add_b5_node(data.id, pos, b4node_names.full_list, diam);
                        parity_of_tap = 'odd';
                        cy.$id(data.id).style({
                           'label': `b4`,
                           'shape': 'hexagon',
                            'background-color': '	#fdfa72',
                            'border-color': '#F6BE00'
                           
                         })
                      } else {
                         cy.remove(`node[type = "b4 property"]`);
                         cy.remove(`node[type = "b5 property"]`);

                         cy.$id(data.id).style({
                           'label': `b4: [${rest_names}]`,
                           'shape': 'ellipse',
                           'background-color': '#CBC3E3',
                          'border-color': '#301934',
                         });
                         parity_of_tap = 'even';
                      }
                });
              }
    
      }


      
      function add_subtax_rank_nodes(subtax_rank, node_qval, radius, 
            mult_constant, prop_node_diam, pos, graphType_pc_edges,                 
            given_taxon, all_ranks, pc_edges, taxon_qvals, 
            parent_and_all_children, nodes_we_came_from, degree_movement) {
            
            let subtax_node_id= subtax_rank['subTaxonOf'];
            let rank_node_name = subtax_rank['taxonRank'];
            let subtax_node_name = subtax_rank['subtax_identifier'];
          
            let subTaxonOf_degree = 0;
            let taxon_x_pos = pos.x;
            let taxon_y_pos = pos.y;
            let parent_node;
            let old_radius;
            let x_dist;
            let new_parent_pos;
            let node_id;
            let new_subtax_node;
            let new_subtax_edge;
            let id_label;

            if (subtax_node_id != undefined) {
                    parent_node = graphType_pc_edges[node_qval];

                    //first adding the subTaxonOf property node
                    parent_pos= cy.nodes(`node[id = "${parent_node}"]`).position();
                    //getting the original radius of the subTaxonOf node
                    old_radius = Math.sqrt(Math.pow(taxon_x_pos - parent_pos.x, 2) + Math.pow(taxon_y_pos - parent_pos.y, 2));
                  
                    x_dist = parent_pos.x - taxon_x_pos;  //need to do this to pretend that taxon is at an origin
                    
                    subTaxonOf_degree = Math.acos(x_dist/old_radius);
                    
                    new_parent_pos = {x: taxon_x_pos + radius * mult_constant * (Math.cos(subTaxonOf_degree)),  y: taxon_y_pos - radius * (mult_constant * Math.sin(subTaxonOf_degree))
                                        };
                    node_id = `prop ${subtax_node_id}`;
                    new_subtax_node = 
                      {
                      group: 'nodes',
                      data: {
                        id: node_id,
                        color: '#ADD8E6',
                        name: subtax_node_name,
                        opacity: 1,
                        width: 250,
                        height: 250,
                        type: 'subTaxProp'
                      },
                      position: new_parent_pos
                      };
                    new_subtax_edge = 
                        {
                      group: 'edges',
                      data: 
                          {
                              id: node_id.concat(node_qval),
                              source: node_qval, 
                              target: node_id,
                              label: 'subTaxonOf'
                          }
                        };

                    cy.add([new_subtax_node, new_subtax_edge]);
                    
                    //now we want to add the clickable feature to these subtax_nodes;
                    //so the last_id_clicked is the current taxon
                    //node_id is the subtax node id but we want the query to run on the 'parent_node' id
                    subtax_node_id_label = `[id = "${node_id}"]`;
                    cy.nodes(subtax_node_id_label).on('click', function(evt) {
                        let evtTarget = evt.target;
                        let data = evtTarget.data();

                        let navDisplayParent = document.getElementById("navigation-history");
                        navDisplayParent.innerHTML = "";
                        let new_nodes_we_came_from = [...nodes_we_came_from]
                        new_nodes_we_came_from.push(node_qval);
                          get_properties(given_taxon, parent_node, all_ranks,
                        pc_edges, prop_node_diam, graphType_pc_edges, node_qval, taxon_qvals, 
                        parent_and_all_children,new_nodes_we_came_from);
                         
                    });

                    cy.nodes(subtax_node_id_label).on('mouseover', function(evt) {
                        let evtTarget = evt.target;
                        let data = evtTarget.data();
                        let enlarged_node_size = 275;
                        let border_color = '#00008B';
                        cy.$id(this.id()).style({
                          'width': enlarged_node_size,
                          'height': enlarged_node_size,
                          'border-color': border_color
                        });   
                    });
                    cy.nodes(subtax_node_id_label).on("mouseout", function(evt) {
                      let reg_node_size = 250;
                      cy.$id(this.id()).style({
                        'width': reg_node_size,
                        'height': reg_node_size,
                      });
                    });
            }

            
            //now need to add the rank node
            if (rank_node_name == undefined) {
                return subTaxonOf_degree;
            }
            
            let rank_pos;
            let next_x_pos;
            let next_y_pos;

            if (Math.abs(subTaxonOf_degree - Math.PI)* (180/Math.PI) <= 15) {
                next_x_pos = taxon_x_pos + (radius*mult_constant)*(Math.cos(degree_movement + subTaxonOf_degree));
                next_y_pos = taxon_y_pos - (radius*mult_constant)*(Math.sin(degree_movement + subTaxonOf_degree));
                rank_pos = {x: next_x_pos, y: next_y_pos};
                subTaxonOf_degree = degree_movement + subTaxonOf_degree;
            } else {
                rank_pos = {x: taxon_x_pos - radius * mult_constant, y: taxon_y_pos};
            }
            let rank_node_id = `prop ${rank_node_name}`;
            let new_rank_node = 
              {group: 'nodes',
                data: {
                  id: rank_node_id,
                  color: '#90EE90',
                  name: rank_node_name,
                  opacity: 1,
                  width: 150,
                  height: 150,
                  type: 'overlay hierarchy',
                },
                position: rank_pos
              };
             cy.add([new_rank_node]);
             let new_rank_edge = 
                {
                  group: 'edges',
                  data: 
                    { id: rank_node_id.concat(node_qval),
                      source: node_qval, 
                      target: rank_node_id,
                      label: 'taxonRank'
                    }
                };
            cy.add([new_rank_edge]);

            // Mouseover Functionality (ranks) to indicate clickability
            cy.on('mouseover', 'node[clickable = "true"]', function(event) {
              let data = event.target.data();
              let node = cy.$id(data.id);
              node.style({
                'width': 150*1.1, // Hard-coded for now
                'height': 150*1.1,
              }); 
            })
            cy.on('mouseout', 'node[clickable = "true"]', function(event) {           
              let data = event.target.data();
              let node = cy.$id(data.id);
              let expanded_width = node.width();
              let expanded_height = node.height();
              node.style({
                'width': 150,
                'height': 150,
              }); 
          });
          return [rank_pos, subTaxonOf_degree];
      
      
      }

      function create_collapsable_def_box(full_def, num_lines, node_id, prop_node_diam, prop_node_height, old_def) {
          let id_label = `node[id = "${node_id}"]`;
          let new_width = 1000
          
          let new_num_lines = full_def.length/20;
          let def_height = new_num_lines*15 + 50;
          if (full_def.length <= 50) {
            new_width = 500;
          }
          
          let parity_of_tap = 'even';
          let collapsed_node_id = '';

              cy.elements(id_label).on('tap', function(evt) {
                    
                    if (parity_of_tap == 'even') {
                      cy.elements(id_label).style({
                        'background-color': '#ee7600',
                        'width': new_width,
                        'height': def_height,
                        'label': full_def,
                        'text-wrap': 'wrap',
                        'text-max-width': new_width - 20,
                        'border-width': 5,
                        'border-color': '	#ff4d01',
                        'border-style': 'solid',
                        'font-size': 35,
                        'font-family': 'Calibri',
                        'line-height': 1.15

                      });
                      parity_of_tap = 'odd'
                    } else {
                      cy.elements(id_label).style({
                        'background-color': '#FFD580',
                        'width': prop_node_diam,
                        'height': prop_node_height,
                        'label': old_def,
                        'text-wrap': 'wrap',
                        'text-max-width': prop_node_diam - 20,
                        'border-width': 5,
                        'border-color': '#F6BE00',
                        'border-style': 'solid',
                        'font-size': 35,
                        'font-family': 'Calibri',
                        'line-height': 1.15

                        });
                      parity_of_tap = 'even'
                    }
              });
      }

      function box_4_query(json, node_qval, data, 
          pos, pc_edges, prop_node_diam, graphType_pc_edges,
           taxon_qvals, all_ranks, given_taxon, 
           parent_and_all_children, nodes_we_came_from) {
        let prefComparisonList = [];
        let bindings = json.results.bindings;
        //assigning node values to b3 and b4
        //let prefComp_bnode_name = `[`;
       // let rest_prefComp_bnode_name = `[`
        for (let i = 0; i < bindings.length; i++) {
          let comp_value = bindings[i].v2Label;
          if (comp_value != undefined && comp_value.value != 'List' && comp_value.value != 'nil') {
            prefComparisonList.push(comp_value.value); 
          }
        }

        let b4node_names = {full_list: prefComparisonList};
        create_property_nodes(node_qval, data, 
          pos, pc_edges, prop_node_diam, graphType_pc_edges, 
          b4node_names, taxon_qvals, all_ranks, 
          given_taxon, parent_and_all_children, nodes_we_came_from)
      }

      //need this intermediate version because now we have to wait for the result of the b4 query
      function create_property_nodes_intermediate(node_qval, data, 
          pos, pc_edges, prop_node_diam, graphType_pc_edges, taxon_qvals, 
          all_ranks, given_taxon, parent_and_all_children, nodes_we_came_from) {

            let node_name = taxon_qvals[node_qval];
            let url = box_node_query(node_name, true);
              d3.json(url).then(function(json_result) {
                box_4_query(json_result, node_qval, data, 
                   pos, pc_edges, prop_node_diam, graphType_pc_edges, 
                   taxon_qvals, all_ranks, given_taxon,
                    parent_and_all_children, nodes_we_came_from);
              });

      }

      var rank_position;
      //adds the nodes and edges that resemble the properties for the
      //node with id node_name
      function create_property_nodes(node_qval, data, pos, pc_edges, prop_node_diam, graphType_pc_edges, b4node_names, taxon_qvals, all_ranks, given_taxon, parent_and_all_children, nodes_we_came_from) {
            let node_name = taxon_qvals[node_qval]
            let prop_node_height = prop_node_diam;
            let taxon_x_pos = pos.x;
            let taxon_y_pos = pos.y;
            let added_els = [];
            let new_diam = prop_node_diam;
            let rank; 
            
            //first want to trim down our redundancy in our query
            let new_prop_data = trim_prop_query(data.results.bindings);
            let bnode_properties = new_prop_data.bnodes_obj;
            let new_property_array = new_prop_data.prop_array;
            let num_property_nodes = new_property_array.length;
            let mult_constant = 10;
            //let mult_constant = prop_node_diam/num_property_nodes;


            //calculate placement of first property node
            //+2 because need to account for adding the subtaxonOf node
            //and the rank node which aren't present in new_property_array.length;
            let circumference = (num_property_nodes + 2) * 50;
            let radius = circumference / (2* Math.PI);
            let curr_degree = 0;
            let degree_movement = (2 * Math.PI) / (num_property_nodes + 2);

            let new_degree = 0;
            let box_nodes = {};

            let assigned_node_type = 'concept';
            let collapse_full_def = 'null';      
            let collapse_node_id = 'null';
            let collapse_num_lines = 0;

            let prop_node_type;
            let prop_node_val;
            let pred_val;
            let num_lines;
            let node_id;
            let image;
            let height;
            let width;
            let next_x_pos;
            let next_y_pos;
            let bnode_props;
            let collapse_diam = prop_node_diam;
            let collapse_height = prop_node_height


            //going to apply the over_lay property to the subtax and rank nodes
            var [rank_position, start_degree] = add_subtax_rank_nodes(new_prop_data.subtax_rank,node_qval, radius, mult_constant, prop_node_diam, pos, graphType_pc_edges, given_taxon, all_ranks, pc_edges, taxon_qvals, parent_and_all_children, nodes_we_came_from, degree_movement);
            curr_degree = start_degree;

            for (let x = 0; x < num_property_nodes; x++) {
                  new_diam = prop_node_diam;
                  prop_node_type = 'concept';
                  //we want the object label and the predlabel  
                  prop_node_val = new_property_array[x].objLabel ? new_property_array[x].objLabel.value : new_property_array[x].obj.value;
                  pred_val = new_property_array[x].predLabel ? new_property_array[x].predLabel.value : new_property_array[x].pred.value;

                  prop_node_type = new_property_array[x].obj.type;

                  //I define a line to have <= 15 characters 
                  num_lines = Math.ceil((prop_node_val.length)/15);
                  prop_node_height = num_lines * 50 + 50;

                  node_id = prop_node_val;
                  //check to see if it's not already a node on the graph
                  if (pc_edges[prop_node_val] != undefined || 
                      prop_node_val == ROOT_NAME || prop_node_val == node_name) {
                      node_id = prop_node_val.concat(x.toString());
                  }
                  if (prop_node_type == 'literal') {
                      prop_node_val = `"${prop_node_val}"`;
                      assigned_node_type = 'literal';
                      new_diam = 250;}

                  else if (pred_val == "taxonImage") {
                      url_id = prop_node_val
                      image = new Image();
                      // image.crossOrigin = "null";
                      image.src = prop_node_val;
                      image.onload = function() {
                        height = image.naturalHeight;
                        width = image.naturalWidth;
                        cy.$id(url_id).data({
                          'width': width,
                          'height': height
                        }); 
                        cy.$id(url_id).data('href', image.src);
                        cy.$id(url_id).style({
                          'background-image': image.src,
                        });  
                      }
                      assigned_node_type = 'image';
                  } else {
                    //prop_node_type is a concept so we want to ideally get q identifier
                    assigned_node_type = 'concept';
                    prop_node_height = 250;
                    new_diam = 250;
                  }

                  if (pred_val == 'definition') {
                    new_diam = 250;
                    node_id = `${node_id}:def`;
                   // assigned_node_type = 'literall';
                    //If a definition has >=3 lines then we want to implement the collapsable
                    //box feature and change the propnodeval to be something shorter.
                    // This seems to be hardcoded: how is prop_node_height retrieved at all? 
                        if (num_lines > 3) {
                          collapse_full_def = prop_node_val;
                          collapse_node_id = node_id;
                          collapse_num_lines = num_lines;
                          
                          //want to slice it at 45 because that's 3 lines
                          prop_node_val = `${prop_node_val.slice(0, 45)} ... \n \ more `;
                          collapse_prop_node_val = prop_node_val;
                        }
                    prop_node_height = 3*50 + 50;
                    assigned_node_type = 'property definition';
                  }

                  if (prop_node_val != undefined) {  

                              new_degree = (curr_degree + degree_movement) % (2 * Math.PI);

                              // case on image here 
                              if (pred_val == "taxonImage") {
                                assigned_node_type = 'image';
                                next_x_pos = taxon_x_pos + (radius*1.8*mult_constant)*(Math.cos(new_degree));
                                next_y_pos = taxon_y_pos - (radius*1.8*mult_constant)*(Math.sin(new_degree));
                                // prop_node_val = '';
                                // cy.nodes('[id = node id]').style(
                                //   { label: new label});
                              }
                              else if (prop_node_type == "bnode") {
                                    new_diam = prop_node_height + 50;
                                    assigned_node_type = 'bnode'
                                    if (new_degree >= ((7/8)*Math.PI) && new_degree <= Math.PI
                                    || new_degree >= Math.PI && new_degree <= (9/8)*Math.PI) {

                                        new_degree = (new_degree + degree_movement) % (2 * Math.PI);

                                    }
                                    next_x_pos = taxon_x_pos + (radius*1.7*mult_constant)*(Math.cos(new_degree));
                                    next_y_pos = taxon_y_pos - (radius*1.7*mult_constant)*(Math.sin(new_degree));
                                    
                                    bnode_props = bnode_properties[prop_node_val];

                                    if (bnode_props.length  >= 2) {
                                        let pred2Label = bnode_props[0].pred2Label;
                                        if (pred2Label != undefined) {
                                          if (pred2Label.value == 'unit') {

                                              let number = bnode_props[1].obj2;
                                              let units = bnode_props[0].obj2Label.value;

                                              prop_node_val = `${prop_node_val}: ${number} ${units}`;
                                          } else {
                                            let prefcomparison = bnode_props[0].obj2Label.value;
                                            prop_node_val = `${prop_node_val}: [${(b4node_names.full_list).join(', ')}]`;
                                          }
                                        }
                                    }
                              } else {
                                
                                
                                if (new_degree <= Math.PI && new_degree >= ((5/6)*Math.PI)
                                || new_degree >= Math.PI && new_degree <= ((7/6)*Math.PI)) {
                                    new_degree = (new_degree + degree_movement) % (2 * Math.PI);
                                } 
                                next_x_pos = taxon_x_pos + (radius*mult_constant)*(Math.cos(new_degree));
                                next_y_pos = taxon_y_pos - (radius*mult_constant)*(Math.sin(new_degree));
                                
                              }
                              curr_degree = new_degree;
                              // position: {x: next_x_pos, y: next_y_pos}
                              // consoloe.log(next_x_pos,next_y_pos)
                              let new_property_node = 
                                {
                                    group: 'nodes',
                                    data: {
                                      id: node_id,
                                      color: '#FFD580',
                                      name: prop_node_val,
                                      opacity: 1,
                                      width: new_diam,
                                      height: prop_node_height,
                                      type: assigned_node_type
                                    },
                                    position: {x: next_x_pos, y: next_y_pos}
                                };
                                if(assigned_node_type == 'property definition') {
                                  collapse_diam = prop_node_diam;
                                  collapse_height = prop_node_height
                                }
                                
                                if (prop_node_type == 'bnode') {
                                  box_nodes[node_id] = (new_property_node);
                                  
                                }
                                added_els.push(new_property_node);
                                // IF it's an image: add href property (most important identifier of the node). add to class of image nodes too
                                
                                let new_edge = 
                                  {
                                  group: 'edges',
                                  data: 
                                      {
                                        id: node_id.concat(node_qval),
                                        source: node_qval, 
                                        target: node_id,
                                        label: pred_val
                                      }
                                  };

                                  added_els.push(new_edge);
                                  
                    }
                        
              }     

                    cy.add(added_els);

                    let id_label = `[id = '${node_qval}']`
                    let clientWidth = document.getElementById('cy').clientWidth;
                    let clientHeight = document.getElementById('cy').clientHeight;
                    let smaller_space = Math.min(clientWidth, clientHeight);

                    //for num_property_nodes = 9, want clientHeight / 2.17
                    //for num_property_nodes = 6, want clientHeight / 2.4;
                    let padding_amount = Math.floor(clientHeight / 2.3);
                    if (num_property_nodes >= 8) {
                      padding_amount = Math.floor(clientHeight/2.17);
                    }

                    //zoom on the selected node enough to display all of the properties
                    cy.animate({
                      fit: {
                        eles: id_label, 
                        padding: padding_amount
                      }
                    });
      
                    cy.elements().edges().style({'font-size': '30'});
                    let parity_dictionary = {}
                    for (const[key, value] of Object.entries(box_nodes)) {

                            let id_label = `node[id = "${key}"]`;
                            parity_dictionary[`parity_of_tap_${key}`] = 'even';  //a way of creating a "new" let for each bnode
                            let all_names = (b4node_names.full_list).join(', ');
                            cy.nodes(id_label).on('tap', function(evt) {
                                  let data = evt.target.data();
                                  if (parity_dictionary[`parity_of_tap_${data.id}`] == 'even') {
                                      //bnode_name, box_nodes, bnode_properties, cy
                                      cy.nodes(`[id = "${data.id}"]`).style({
                                        'shape': 'hexagon',
                                        'background-color': '	#fdfa72',
                                        'border-color': '#F6BE00'
                                      });

                                      if (key == 'b3') {
                                            cy.nodes(id_label).style({
                                            'label': `b3`
                                            });
                                      }
                                      add_values_to_bnode(data.id, box_nodes, bnode_properties, 
                                      padding_amount, taxon_x_pos, taxon_y_pos, b4node_names);
                                      parity_dictionary[`parity_of_tap_${data.id}`] = 'odd';
                                      
                                      

                                  } else {
                                      parity_dictionary[`parity_of_tap_${data.id}`] = 'even';

                                      cy.nodes(`[id = "${data.id}"]`).style({
                                        'shape': 'ellipse',
                                        'background-color': '	#CBC3E3',
                                        'border-color': '#301934',
                                        'border-style': 'solid'
                                      });

                                      cy.remove(`node[type = "${data.id} property"]`);
                                      
                                      if (key == 'b3') {
                                          cy.remove( `node[type = "b4 property"]`);
                                          cy.remove(`node[type = "b5 property"]`);
                                            cy.nodes(id_label).style({
                                            'label': `b3: [${all_names}]`
                                            });
                                      }
                                      
                                      
                                  }
                                  
                            }); 

                    }
                    //should only do this if full_def is redefined.
                    if (collapse_full_def != 'null') {
                        create_collapsable_def_box(collapse_full_def, 
                        collapse_num_lines, collapse_node_id, collapse_diam, collapse_height, collapse_prop_node_val);
                    }
                  
                // Add expandable subgraph to rank
                let rank_name = new_prop_data.subtax_rank['taxonRank'];
                let ranks_id = 'prop ' + rank_name;
                // Make rank nodes parent nodes, adding expandable feature
                // Open NEW subgraph with browser ranks information 
                display_ranks(node_qval, ranks_id, rank_position);

                cy.on("expandcollapse.afterexpand", function(event) {
                  document.getElementById("Collapse").style.visibility='visible';

                  let evtTarget = event.target;
                  let object = evtTarget.data();
                  let expanded_id = object['id'];
                  let expanded_type = object['type'];
                  let original_position = {
                    'x': object['x-before-fisheye'] - 1000, 
                    'y': object['y-before-fisheye']
                  };
                  cy.$id(expanded_id).data('reverted', 'false');

                  if (expanded_type == "overlay hierarchy") {
                    // Ideally, shift nodes should work for all. Figure out why it doesn't. 
                    shift_nodes(names_to_qvals[rank_name], original_position);
                    
                    // Remove old edge + add new edge
                    cy.remove(`[label = 'taxonRank']`);
                    var rank_edge = {
                      group: 'edges',
                      data: 
                        {id: `${node_qval} - ${names_to_qvals[rank_name]}`, 
                        source: node_qval, 
                        target: names_to_qvals[rank_name], 
                        label: 'taxonRank',
                        },
                    }
                    cy.add(rank_edge)
                  };
                  
                });

                cy.on("expandcollapse.beforecollapse", function(event) {
                  let evtTarget = event.target;
                  let object = evtTarget.data();
                  let box_id = object['id'];
                  let expanded_type = object['type'];

                  // Define Nodes
                  let outer = cy.$id(box_id); // Which is what we clicked on

                  if ('isExpandable' in object && object['isExpandable'] == "true") {
                    let inner_id = box_id.replace('V2: ', '');
                    let inner = cy.$id(inner_id);
                    let incomers = inner.incomers('edge');

                    // Make sure its edges render correctly 
                    if (outer.isOrphan()) {
                      // Two cases exist: existence is determined by whether there is an edge with the target of thie id                     
                      // Case 1: absolutely no arrows connecting inwards: a loner node ==> if we collapse this, we need to simply REMOVE this node, including all of its children.
                      if (incomers.length == 0) { // total orphan 
                        cy.remove(outer); // Kills node completely 
                      }                    
                      else {
                        // Case 2: there's an arrow connecting inwards (the node/property is still attached to another node); when collapsed, it must revert BACK to a child of its parent node.    
                        let og_parent = inner.data('originalParent');
                        collapse(inner, og_parent, outer, incomers);
                      }
                    }
                    else {
                      let parent = outer.parent();
                      collapse(inner, parent.data('id'), outer, incomers);
                    };
                  } 
                  
                  // Applies to the outer nodes that contain all the mini expand/collapse stuff
                  if (expanded_type == "overlay hierarchy") {
                    revert_position(outer.data('id'));
                    cy.remove(`[class = "property"]`);
                    cy.remove(`[class = "property-edge"]`);
                    document.getElementById("Collapse").style.visibility='hidden';
                  }
                })
       
            }

              
      function show_property_nodes(node_qval, data, pc_edges, 
      prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, all_ranks, 
      given_taxon, parent_and_all_children, nodes_we_came_from) {            
            let id_label = `[id= '${node_qval}']`;
            let pos = cy.nodes(id_label).position();

            shade_other_nodes(node_qval, id_lastclicked_node);
            create_property_nodes_intermediate(node_qval, data, pos, pc_edges, 
            prop_node_diam, graphType_pc_edges, taxon_qvals, all_ranks, given_taxon, 
            parent_and_all_children, nodes_we_came_from);

      }

      //returns the hierarchy back to it's original state
      //after the user unselects a node
      function return_to_normal(node_name, given_taxon, click_of_subtax, farthest_second_left_child_pos) {
            document.getElementById("Collapse").style.visibility='hidden';
            let navDisplayParent = document.getElementById("navigation-history");
            navDisplayParent.innerHTML = "";

            let navButtonsParent = document.getElementById("show-nav-buttons");
            navButtonsParent.innerHTML = "";

            if (!click_of_subtax) {
                //changing the nodes back to their original styles
                  cy.elements().nodes().style( 
                    { 'opacity' : '1',
                      'text-opacity': '1'
                    });

                  //let nodes = cy.elements().nodes();
                  cy.nodes(`node[type = "rank"]`).style({
                            "background-color": "#90EE90",
                            'text-wrap': 'wrap',
                            'text-max-width': 150,
                            'font-size': 35,
                            'font-family': 'Calibri',
                            'line-height': 1.15
                          });
                  cy.nodes(`node[type = "taxon"]`).style({
                            "background-color": "#ADD8E6",
                          });
                          cy.elements().edges().style( 
                            { 'line-opacity' : '1',
                              'text-opacity': '1'
                            });
            }
            

            //changing the edges back to their original styles
            let id_label = `[id = '${node_name}']`;
            cy.nodes(id_label).style("background-color", "#ADD8E6");
            if (click_of_subtax) {
              cy.nodes(id_label).style("opacity", ".2");

            }
            
            id_label = `[id = '${given_taxon}']`;
            cy.nodes(id_label).style("background-color", "red");
            cy.elements().nodes().style({'border-width': '0'});

            // Remove all nodes
            to_remove.forEach(function (item, index) {
              cy.remove(item);
            });
                   
            if (!click_of_subtax) {
                  cy.fit({
                    padding: 19
                  });
                
                cy.animate({
                  zoom: {
                    level: .02,
                    position: {x: farthest_second_left_child_pos.x, y: 0}
                  },
                });
            }
            rank_removal.restore();
            rank_removed = false;
      }

      function display_nav_buttons(node_qval, graphType_pc_edges, taxon_qvals, parent_and_all_children) {

        let right_arrow_head_color = 'white';
        let left_arrow_head_color = 'white';
        let down_arrow_head_color = 'white';

        let curr_taxon_name = taxon_qvals[node_qval];
        let middle_nav_width = curr_taxon_name.length/.2;

        
        let curr_parent = graphType_pc_edges[node_qval];
        let curr_parent_name = taxon_qvals[curr_parent];
        let up_arrow_head_color = 'rgb(0, 170, 255)';

        if (curr_parent_name == undefined || curr_parent == 'root') {
          curr_parent_name = " ";
          curr_parent = " ";
          up_arrow_head_color = 'white';
        }
        
        let relationships = ["nav-up", "nav-down", "nav-left", "nav-right"];

        let all_siblings = parent_and_all_children[curr_parent];
        let children = parent_and_all_children[node_qval];
        let left_sibling_name = " ";
        let right_sibling_name = " ";
        let first_child_name = " ";

        let left_sibling = " ";
        let right_sibling = " ";
        let first_child = " ";
        let idx_of_curr_node;



        if (all_siblings != undefined && all_siblings.length > 1) {
          //means there exists other siblings
          idx_of_curr_node = all_siblings.indexOf(node_qval);
          if (idx_of_curr_node > 0) {
              left_sibling = all_siblings[idx_of_curr_node - 1];
              left_sibling_name = taxon_qvals[left_sibling];
              left_arrow_head_color = 'rgb(0, 170, 255)'
          }
          if (idx_of_curr_node < (all_siblings.length - 1)) {
            right_sibling = all_siblings[idx_of_curr_node + 1];
             right_sibling_name = taxon_qvals[right_sibling];
             right_arrow_head_color = 'rgb(0, 170, 255)'
          }
        }

        if (children != undefined && children.length > 0) {
          first_child = children[0];
          first_child_name = taxon_qvals[first_child];
          down_arrow_head_color = 'rgb(0, 170, 255)';
        }
        let arrow_head_colors = [up_arrow_head_color, down_arrow_head_color,
            left_arrow_head_color, right_arrow_head_color];

        let navbuttons = document.getElementById("show-nav-buttons");
            navbuttons.innerHTML = 
            `<div id = "navigation-buttons" style="width: 100%">
              <div style="float:right; text-align: center; margin-right: 70px;">
                  <button id='nav-up' class="nav-buttons" type="button" style="display: inline-block; border-width:0px"> 
                    <span id = 'nav-up-text' style="font-size:15px; color:${up_arrow_head_color}">${curr_parent_name}</span> 
                    <br>
                    <span id = 'nav-up-arrow' style="font-size:15px; color:${up_arrow_head_color}">\u25B2</span> 
                  </button>
  
                  <div style="display:flex">
                    <button id='nav-left' class="nav-buttons" type="button" style="border-width:0px; position: relative; text-align:right">
                      <span id = 'nav-left-arrow' style="font-size:15px; color:${left_arrow_head_color}">${left_sibling_name}    \u25C0</span> 
                    </button>
    
                    <button id="middle-nav" class="nav-buttons" type="button" 
                    style="display: block; font-size: 12px; color:#fff3f4; border-width:0px;">
                    ${curr_taxon_name}
                    </button>
  
                    <button id='nav-right' class="nav-buttons" type="button" style="border-width:0px; position: relative; text-align:left">
                      <span id = 'nav-right-arrow' style="font-size:15px;  color:${right_arrow_head_color}">\u25B6    ${right_sibling_name}</span> 
                    </button>
                   </div>
                  <button id='nav-down' class="nav-buttons" type="button" style="display: inline-block; border-width:0px;"> 
                    <span id = 'nav-down-arrow' style="font-size:15px; color:${down_arrow_head_color}">\u25BC</span> 
                      <br>
                      <span id = 'nav-down-text' style="font-size:15px; color:${down_arrow_head_color}">${first_child_name}</span> 
                    </button>
                  <br>             
              </div>
           </div>`
           
           

           //now we need to add different hover events based on what places we can actually move to
           let idx = 0;
           relationships.forEach(curr_relationship_id => {

              let curr_arrow_color = arrow_head_colors[idx];
              let nav_btn;
              if (curr_arrow_color != 'white') {
                  nav_btn = document.getElementById(curr_relationship_id)
                  nav_btn.addEventListener("mouseover", 
                  function() {
                      document.getElementById(`${curr_relationship_id}-arrow`).style.color = '#00008B';
                      nav_btn.style.backgroundColor = '#D4F1F4';
                      nav_btn.style.borderWidth = "1px";
                      nav_btn.style.borderColor = '#ADD8E6';
                  });
                  nav_btn.addEventListener("mouseout", 
                  function() {
                      document.getElementById(`${curr_relationship_id}-arrow`).style.color = curr_arrow_color;
                      nav_btn.style.backgroundColor = 'white';
                      nav_btn.style.borderWidth = "0px";
                      nav_btn.style.height = '40px';
                  });
              }
              idx += 1;

           })

           //13 has width 150
           //150 = 13*const
           //=>const = 11.5
           //
           const button_size_increase = 11.6
           let new_width;
           if (right_sibling_name.length >= 13){
                new_width = button_size_increase * (right_sibling_name.length);
                document.getElementById("nav-right").style.width = `${new_width}px`;
                document.getElementById("nav-left").style.width = `${new_width}px`;
           }
           if (left_sibling_name.length >= 13){
                new_width = button_size_increase * (left_sibling_name.length);
                document.getElementById("nav-left").style.width = `${new_width}px`;
                document.getElementById("nav-right").style.width = `${new_width}px`;
           }

           return [first_child, left_sibling, right_sibling, curr_parent]
      }

      //only want this function to perform the query if we select a non-rank node
      function get_properties(given_taxon, node_qval, all_ranks,
       pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, 
       parent_and_all_children, nodes_we_came_from) {

            let four_relationships_qvals = display_nav_buttons(node_qval, graphType_pc_edges, taxon_qvals, parent_and_all_children);
            let relationships = ["nav-down", "nav-left", "nav-right", "nav-up"];
            //relationships needs to be in the same order as is returned by the function display nav buttons
            let idx = 0;
            //adding click events for the navigation buttons
            four_relationships_qvals.forEach(qval => {
                let nodes_lst = [];

                let curr_relationship_id = relationships[idx];
                if (curr_relationship_id == "nav-up") {
                  nodes_lst = [...nodes_we_came_from]
                  nodes_lst.push(node_qval);
                } else {
                  nodes_lst = [];
                }
                if (qval != " ") {
                  document.getElementById(`${curr_relationship_id}`).addEventListener('click', function() {
                      get_properties(given_taxon, qval, all_ranks,
                      pc_edges, prop_node_diam, graphType_pc_edges, node_qval, taxon_qvals, parent_and_all_children, nodes_lst)
                  })
                }
                idx +=1;
            });
            

            let curr_parent = graphType_pc_edges[node_qval];
            let navDisplayParent = document.getElementById("navigation-history");
            navDisplayParent.innerHTML = "";
            
            let id_label =`[id = '${given_taxon}']`;
            cy.nodes(id_label).style({
              "background-color": "red",
              'border-width': 0
            });
            
            let node_name = taxon_qvals[node_qval];

            // Remove all necessary elements
            to_remove.forEach(function (item, index) {
              cy.remove(item);
            });

            if (!rank_removed) {
              rank_removal = cy.remove(`node[type = "rank"]`);
              rank_removed = true;
            }
            // Restoring previous rank nodes
            
        if (all_ranks.includes(node_name)) {
          return false;
        }

        show_navigation_history(given_taxon, node_qval, all_ranks,
        pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, 
        parent_and_all_children, nodes_we_came_from);

        let url = property_query(node_name, true);
          d3.json(url).then(function(json) {
            show_property_nodes(node_qval, json, pc_edges,
             prop_node_diam, graphType_pc_edges, id_lastclicked_node, 
             taxon_qvals, all_ranks, given_taxon, parent_and_all_children, nodes_we_came_from);
          })
      }



      function get_definition(node_name, all_ranks, definitions, definition_node_size) {

          if (all_ranks.includes(node_name)) {
            return false;
          }
          let def_node_height;
          let text_just = 'center';
        
          let taxon_def = definitions[node_name];
          if (taxon_def == undefined || taxon_def == "") {
            taxon_def = "No definition available";
          }

          let pos = cy.$id(node_name).position();

          let def_length = taxon_def.length;
          
          let num_lines = Math.ceil(def_length/15);
          let definition_node_height = num_lines*90 + 50;

          let right_shift = 600
          if (num_lines > 3) {
              definition_node_size = 1900
          
              let new_num_lines = def_length/20;
              let definition_node_height = new_num_lines*40 + 50;
              right_shift = 1300
              if (def_length <= 50) {
                definition_node_height = new_num_lines*100 + 100;
                definition_node_size = 500;
                right_shift = 500;
              }
              
          }
          
          if (num_lines > 1) {
            text_just = 'left'
          }

          def_node = {
            group: 'nodes',
            data: {
              id: taxon_def,
              color: '#FFB6C1',
              name: taxon_def,
              opacity: 1,
              width: definition_node_size,
              height: definition_node_height,
              type: 'definition'
            },
              position: {x: pos.x + right_shift , y: pos.y}
        };
          def_edge = {
            group: 'edges',
            data: 
                {
                    id: taxon_def.concat(node_name),
                    source: node_name, 
                    target: taxon_def,
                    label: 'DEF',
                }
          };
          cy.add(def_node);
          cy.add(def_edge);

          let id_selector = `node[width = ${definition_node_size.toString()}]`;
          cy.style().selector(id_selector).style({
            'shape': 'rectangle',
            'text-wrap': 'wrap',
            'text-justification': text_just,
            'text-valign': 'center',
            'text-max-width': definition_node_size - 20,
            'border-width': 5,
            'border-color': '#FF007F',
            'border-style': 'solid',
            'font-size': 75,
            'font-family': 'Calibri',
            'line-height': 1.15

          });
          let edge_id_label = `[id = '${taxon_def.concat(node_name)}']`;
          cy.edges(edge_id_label).style({
            'line-color': '#FF007F',
            'target-arrow-color': '#FF007F',
            'color': 'white',
            'width': 20
          });
          
      }

    
      //when a user is at a node, we want to show the navigation history of a node i.e first want to get it
      //where we can display everything above the node
     function show_navigation_history(given_taxon, node_qval, all_ranks,
        pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, 
        taxon_qvals, parent_and_all_children, nodes_we_came_from) {


          let prev_nodes_we_came_from = [...nodes_we_came_from];
          let node_ids_above = [];
          let node_names_above = []
          let curr_node = node_qval;
          let curr_node_name = taxon_qvals[node_qval];
          let nodes_above_length = 0;
          let node_id_below;

          //Q2382443 is the q val for Animalia, Q729 is for Animalia

          for (let i = 0; i < nodes_we_came_from.length; i++) {
            node_below_id = nodes_we_came_from[i]
            node_ids_above.push(node_below_id);
            node_names_above.push(taxon_qvals[node_below_id]);
          }

          while (curr_node != ROOT_QVAL || curr_node == undefined) {
            node_ids_above.push(curr_node);
            node_names_above.push(taxon_qvals[curr_node]);
            curr_node = graphType_pc_edges[curr_node];
            nodes_above_length += 1;
          }
          node_names_above.push(ROOT_NAME);
          nodes_above_length +=1;
          node_ids_above.push(ROOT_QVAL);

          //want to add nodes_we_came_from to the displayed list in the navigation history
      

          node_names_above = node_names_above.reverse();
          node_ids_above = node_ids_above.reverse();

          let navDisplayParent = document.getElementById("navigation-history");
          let length = node_names_above.length;
          let nodes_above_text = "";
          let buttonID;
          let idx = 0;
          let curr_button_id = "";
          
          let prev_nodes_we_came_from_length = nodes_we_came_from.length;

          let new_nodes_we_came_from = [...nodes_we_came_from];
          new_nodes_we_came_from.push(node_qval);

          navDisplayParent.style.marginTop = "30px";

          node_names_above.forEach(taxon_name =>{
              
              let node_id = node_ids_above[idx];
              let button = document.createElement("BUTTON");
              button.style.backgroundColor = "white";
              button.style.fontWeight = '550';

              if (node_id == node_qval) {
                if (prev_nodes_we_came_from_length != 0) {

                  button.innerHTML = `${taxon_name} \u25C0`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';

                } else {
                  button.innerHTML = `${taxon_name}`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';
                }
                button.style.color = '#FF69B4';
                button.addEventListener("mouseover", function() {
                button.style.fontWeight = '700';
                button.style.color = ' #AA336A';

              });
              button.addEventListener("mouseout", function() {
                button.style.color = ' #FF69B4';
                button.style.fontWeight = '550';
                button.style.backgroundColor = 'white';
              });

              } else {
                if (idx == node_names_above.length - 1 ) {
                  button.innerHTML = `${taxon_name}`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';

                } else {
                  button.innerHTML = `${taxon_name} \u25C0`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';
                
                }
                button.style.color = '#03a9f4';
                button.addEventListener("mouseover", function() {
                    button.style.color = ' #03018C';
                    button.style.fontWeight = '700';
                });
              button.addEventListener("mouseout", function() {
                button.style.color = '#03a9f4';
                button.style.fontWeight = '550';
              })

              }


              button.style.borderRadius = "50px";
              curr_button_id = `${taxon_name}-history-display`
              button.id = curr_button_id;
              button.style.border = 0;
              let nodes_lst = [];

              if (idx >= nodes_above_length) {
                    nodes_lst = [];
              }else if (node_id == node_qval) {
                    nodes_lst = prev_nodes_we_came_from;
              } else {
                    nodes_lst = new_nodes_we_came_from;
              }
              button.addEventListener("click", function() {
                      get_properties(given_taxon, node_id, all_ranks,
                      pc_edges, prop_node_diam, graphType_pc_edges, node_qval, taxon_qvals, parent_and_all_children,
                      nodes_lst);
              });
              navDisplayParent.appendChild(button);
              idx += 1;

          })
          let cy_container = document.getElementById("cy");
          cy_container.style.height = "65vh";
     }


      // Elongate nodes, given a source node and a child node (think of a center node and properties around it)
      function extend_nodes(id, source_pos, child_pos){
        // Calculate distance between the two points
        let x_diff = child_pos['x'] - source_pos['x'];
        let y_diff = child_pos['y'] - source_pos['y'];

        // Keep track of the difference to access later when reverting position
        positions[id] = {'x': x_diff, 'y': y_diff};

        // Elongate
        let x = child_pos['x'] + 1.8*x_diff;
        let y = child_pos['y'] + 1.8*y_diff;
        return {'x': x, 'y':y};
        }
    
      // Input: number of properties to display in one circle, the desired diameter, all relative to the original location. Returns a list of all the new positions, relative to the number or properties
      // Goal: apply this to the rank properties... 
      function calculate_positions(properties, center, diameter) {
        var num_properties = properties.length;
        var radius = diameter/2;
        var angle = 2*Math.PI/num_properties; // in radians
        // Manually calculate where the rest of the properties go 
        for (let i = 0; i < num_properties; i++) {
          var curr_angle = angle*i + Math.PI/num_properties;
          var x = center['x'] + radius*Math.cos(curr_angle);
          var y  = center['y'] + radius*Math.sin(curr_angle);
          var curr_node = properties[i];
          curr_node['position'] = {'x': x, 'y': y};
          properties[i] = curr_node;
        }
        return properties;
      }

    // Shifts entire group of nodes in regards to one singular node
    function shift_nodes(id, desired_position) {
      let position = cy.$id(id).position();
      let position_to_add = {
        'x': desired_position['x'] - position['x'], 
        'y': desired_position['y'] - position['y']};
      let ultimate_parent = id;
      // Loops until we reach the top layer and get the parent
      while (api.getParent(ultimate_parent).length != 0) {
        ultimate_parent = api.getParent(ultimate_parent).data('id');
      }
      // Change position of entire group
      let group_position = cy.$id(ultimate_parent).position()
      cy.$id(ultimate_parent).position({
        'x': group_position['x'] + position_to_add['x'],
        'y': group_position['y'] + position_to_add['y']
      })
    }

    function collapse(inner_node, parent, outer_node, incoming_edge) {
      cy.remove(outer_node);
      inner_node.restore();
      inner_node = inner_node.move({
        parent: parent,
      });
      incoming_edge.restore();
      inner_node.data('clickable', 'true');
      revert_position(inner_node.data('id')); 
    }

    // Often, expandable nodes will collapse to an entirely new position. This function ensures that it will go back to its original position. 
    function revert_position(id) {
      // You still have to use the original position, but also track the location of its source.
      let node = cy.$id(id);
      
      // Calculate node positions: change dynamically to reflect where the original position is. 
      if (id in positions) {
        // Obtain source information 
        let source = node.incomers('node');
        let source_id = source.data('id');

        let source_position = source.position();
        let source_position_x = source_position['x'];
        let source_position_y = source_position['y'];
        var original_position = {
          'x': source_position_x + positions[id]['x'],
          'y': source_position_y + positions[id]['y'],
        };
        node.position({
          'x': original_position['x'],
          'y': original_position['y'],
        });
      }
      else {
        let object = node.data();
        var original_position = {
        'x': object['x-before-fisheye'], 
        'y': object['y-before-fisheye'],
        };
        if (original_position['x'] != undefined && original_position['y'] != undefined ) {
          node.data('position-before-collapse', original_position);
        }
      };
    }

    function extract_q(str) {
      let beginning = str.indexOf('Q');
      if (beginning == -1) {
        return str
      }
      let q_val = '';
      for (i = beginning; i < str.length; i++) {
        if (str[i] != ' ') {
          q_val = q_val.concat(str[i]);
        }
        else{
          break;
        }
      }
      return q_val
    }


    // Dynamically resize node definitons given how long the string is 
    function node_padding(text, max_width) {
      // Some types have already a set width and height; these settings will bypass whatever width/height this function returns. Thus, this function is mainly helpful for labels that nodes will need to dynamically resize to. 
      // Given a string, this function will return a necessary width and height to cover the entire blurb. 
      // Font size is 35, which is approximately the width per line. 
      let padding = 30;
      let font_size = 35;
      let pixels_per_character = 19;
      let characters_per_line = max_width/pixels_per_character;
      let num_lines = Math.floor(text.length/characters_per_line) + 1;
      if (num_lines == 1) {
        max_width = text.length*pixels_per_character;
      }
      return {'width': max_width + 2*padding, 'height': num_lines*font_size + 2*padding};
    }

    function get_node_properties(event, node_parent, expandable) {
      console.log('in get_node_properties');
      // cy.$id(node_parent).style('font-size', 45);
      let evtTarget = event.target;
      let node_id = evtTarget.data('id');
      let node_qval = extract_q(node_id);
      let node_name = evtTarget.data('name');
      let type = evtTarget.data('type');
      const node_position = evtTarget.position();
      let desired_position = node_position; 

      let url = all_properties(node_qval);
      // Must fix this later: we want to keep all expanded properties of the relvant node, and close only other ranks
      d3.json(url).then(function(json_result) {
        var data = json_result.results.bindings;
        let all_nodes = [];
        let all_edges = [];

        let node_id_copy = JSON.parse(JSON.stringify(node_id)); // Ensure doesn't change after; node_id is changed later. 
        // If expandable version, define a new parent node 
        if (expandable == "true"){
          let node = cy.$id(node_id);

          // Make node unclickable, also reduce node size: the event listener declared earlier, which handles reducing node size on "mouseout", is void due to its contingency of the node being CLICKABLE, which we've converted to false here. 
          node.data('clickable', 'false');
          let expanded_width = node.width();
          let expanded_height = node.height();
          node.style({
            'width': expanded_width/1.1,
            'height': expanded_height/1.1,
          }); 

          // Change arrow's target to be the new node, not the old parent (will do this at the end, but access it now).
          let arrow = cy.edges(`[target = "${node_id}"]`);
          
          // Calculate the new, desired position. 
          let source = arrow.sources();
          let source_pos = source.position();
          desired_position = extend_nodes(node_id, source_pos, node_position);

          // NEW node created
          let new_parent_id = `V2: ${node_id}`;
          var parent_node = 
          {
            group: 'nodes',
            data:
              {id: new_parent_id, 
              clickable: 'false',
              name: node_name,
              width: 150, 
              height: 150,
              type: type,
              parent: node_parent,
              class: 'property',
              isExpandable: expandable,
              },
            classes: ['nested'],
            }
          // When creating the edge, it'll attach to this new node. 
          cy.add(parent_node);
          node = node.move({
            parent: new_parent_id,
          });
          cy.$id(new_parent_id).style('font-size', 45);
          node.position({'x': desired_position['x'], 'y': desired_position['y']});

          // Add Event Listener: Allow Popup 
          if (!(nested.includes(new_parent_id))) {
            let node = cy.$id(new_parent_id);
            node.addClass('nested');
            node.addClass('compound'); // Used for styling purposes
            nested.push(new_parent_id); 
            contextMenu.appendMenuItem(
            {
              id: `nodePopOut: ${new_parent_id}`,
              content: `Pop Out Node`,
              selector: `node[id = "${new_parent_id}"]`,
              onClickFunction: function (event) {
                let target = event.target;
                let data = target.data();
                let clicked_node = cy.$id(data.id);
                clicked_node.removeClass('nested');

                // Update its parent
                let originalParent = JSON.parse(JSON.stringify(data['parent']));
                cy.$id(node_id).data('originalParent', originalParent);
                clicked_node = clicked_node.move({
                  parent: node_parent
                });
                // cy.$id(node_parent).style('font-size', 45);
              },
              hasTrailingDivider: true
            },
          );
          };
          
         
          node_parent = new_parent_id;
        }


        // 'x' represents the property name (such as type, subClassOf)
        // 'xLabel' represnts the LABEL of the 'x'. for example, type's value is actually  'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
        // 'y' represents the corresponding value (class, taxonomic rank). it can appear in a variety of formats, such as boltz:, rdfs:, skos:
        // 'yLabel' represnts the LABEL of the 'y'. for example, rdfs:class's value is actually 'http://www.w3.org/2000/01/rdf-schema#Class'
        for (index_key in data) {
          let property_object = data[index_key];
          let property = property_object['x']['value'];
          // Extract property name 
          if ('xLabel' in property_object) {
            property = property_object['xLabel']['value'];
          }
          else {
            property = property.replace('http://solid.boltz.cs.cmu.edu:3030/ontology/', '')
          }

          // Extract property value 
          let property_value = property_object['y']['value'];
          let id = `${property_value} ${property} ${node_qval}`;
          let property_type = property_object['y']['type'];
          let is_clickable = 'false';

          // If type is a literal, it's width/height must be resized to fit the entire text.
          if (property_type == 'literal') {
            property_value = `"${property_value}"`
            let data = node_padding(property_value, 350, 24);
            var width = data['width'];
            var height = data['height'];
          } 
          else {
            var width = 150;
            var height = 150;
          }

          // Extract the property value label (making it readable in a human format)
          if ('yLabel' in property_object) {
              property_value_label = property_object['yLabel']['value'];
              let prefix_link = ''
              let property_prefix = ''
              for (var prefix in prefixes) {
                if (property_value.includes(prefix)) {
                  prefix_link = prefix;
                  property_prefix = prefixes[prefix];
                }
              }
              // Example ID: rdfs:Class, type Q2752679
              property_value = property_value.replace(prefix_link, '');
              id = `${property_prefix}${property_value} ,${property} ${node_qval}`;
              property_value = `${property_value_label} ${property_prefix}${property_value}`;
              is_clickable = 'true';

              // As of right now: boltz concepts are green this code right now is horribly redundant
              if (property_prefix != "boltz:") {
                property_type = "concept";
                is_clickable = "false";
                property_value = property_value_label;
              }
            }

            // HARDCODED FOR THIS EXAMPLE
          if (property == "nextHigherRank" || property == "nextLowerRank") {
            continue
          }
          var property_node = 
          {
            group: 'nodes',
            data:
              {id: id, 
              clickable: is_clickable,
              name:`${property_value}`,
              color: '#90EE90', 
              width: width, 
              height: height,
              type: property_type,
              parent: node_parent,
              class: 'property',
              isExpandable: "true",
              },
            };
          var property_edge = 
          {
            group: 'edges',
            data: 
              {id: `${node_qval} to property ${property}`, 
              source: node_id, 
              target: id, 
              label: property,
              class: 'property-edge',
              },
          };
          all_nodes.push(property_node);
          all_edges.push(property_edge);
        }
          // Update positioning for all properties
          var updated_nodes = calculate_positions(all_nodes, desired_position, 1000);
          // Add to graph
          cy.add(updated_nodes);
          cy.add(all_edges);

          // Add layout to graph
          // if (expandable == "true") {
          //   console.log('hello?')
          //   var rank_layout = cy.nodes(all_nodes).layout({
          //   name: 'cola',
          //   avoidOverlap: true,
          //   nodeDimensionsIncludeLabels: false,
          //   handleDisconnected: false,
          //   centerGraph: false,
          //   fit: false,
          //   nodeSpacing: 100,
          //   });
          //   var edge_layout = cy.nodes(`[class = "property-edge"]`).layout({
          //     name: 'cola',
          //   });
          //   rank_layout.run();
          //   edge_layout.run();
          // }

      })

    }


    function display_ranks(id, rank, position) {
      console.log(rank);
      // let url = all_ranks_query();
      var taxonomic_rank_nodes = [];
      var taxonomic_rank_edges = [];

      var rank_name = rank.replace('prop ', '')
      let url = all_ranks_query(rank_name);
      console.log(url);
      // Goal is to create the nodes out of this json_result
      d3.json(url).then(function(json_result) {
        var data = json_result.results.bindings;
        // Prepare to sort the list
        var ranks_to_object = {}
        var ranks_and_nexthigher = data.map(function(object) {
          let rank = object.rank.value.replace('http://solid.boltz.cs.cmu.edu:3030/data/', '');
          let nextHigher = null;
          if ('nextHigher' in object) {
            nextHigher = object.nextHigher.value.toString().replace('http://solid.boltz.cs.cmu.edu:3030/data/', '');
          }
          ranks_to_object[rank] = object;
          return ([rank, nextHigher]);
        })
        // Sorting function: returns array, where key (rank qval) and value (the order in the hierarchy)
        var nodes = {};
        let done = false;
        while (! done) {
          done = true;
          ranks_and_nexthigher.forEach(p => {
            var rank = p[0];
            var nextHigher = p[1];
            if (nextHigher != null) {
              if (!(Object.keys(nodes).includes(rank))) {
                nodes[rank] = 0;
                nodes[nextHigher] = 0;
              }
              if (nodes[rank] < nodes[nextHigher] + 1) {
                nodes[rank] = nodes[nextHigher] + 1;
                done = false;
            }}
          }
          )
        }
        // Create final array, ordered in the correct rank hierarchy.
        var length = Object.keys(nodes).length;
        var ordered_rank_hierarchy = Array.from(Array(length).keys());
        for (var rank_key in nodes) {
          let rank_index = nodes[rank_key]
          ordered_rank_hierarchy[rank_index] = rank_key
        }
        var local_rank_hierary = JSON.parse(JSON.stringify(ordered_rank_hierarchy));
        if (local_rank_hierary.length > 3) {
          local_rank_hierary.shift(); // mutates original array, should change
        }
        console.log('local rank hierarchy', local_rank_hierary);
        // Goal: automate this process, for all nodes, call a query that returns all of its properties. You make the node with the properties expandable. 
        for (rank_qval of local_rank_hierary) {
          var rank_object = ranks_to_object[rank_qval];
          console.log('ranks to object', ranks_to_object);
          console.log('rank object', rank_object);

          var name = rank_object['rankLabel']['value'];
          qvals_to_names[rank_qval] = name;
          names_to_qvals[name] = rank_qval;
          // Create node object to push onto graph
          var node_obj = {
            group: 'nodes',
            data:
              {id: rank_qval, 
              name:`${name} boltz:${rank_qval}`,
              color: '#90EE90', 
              width: 150, 
              height: 150,
              label: name,
              type: 'display',
              clickable: "true",
              isExpandable: "true",
              parent: rank,
              },
            position: {x: position['x'], y: position['y']},
            };
          cy.add(node_obj);
          taxonomic_rank_nodes.push({node: cy.$id(rank_qval), offset: 0});
          console.log('rank qval is', rank_qval);
          console.log('includes rank qval?', local_rank_hierary.includes(rank_qval));
          // Connecting edge for all concepts
          if ('nextHigher' in rank_object){
            var nextHigher_qval = rank_object.nextHigher.value.toString().replace('http://solid.boltz.cs.cmu.edu:3030/data/', '');
            if (local_rank_hierary.includes(rank_qval) && local_rank_hierary.includes(nextHigher_qval)) {
              connecting_edge = {
              group: 'edges',
              data:
                {id: `${rank_qval} to ${nextHigher_qval}`, 
                source: rank_qval, 
                target: nextHigher_qval,
                type: 'hierarchy: up',
                label: '',
                },
              }
              taxonomic_rank_edges.push(connecting_edge);
            }
          }
          if ('nextLower' in rank_object){
            var nextLower_qval = rank_object.nextLower.value.toString().replace('http://solid.boltz.cs.cmu.edu:3030/data/', '');
            if (local_rank_hierary.includes(rank_qval) && local_rank_hierary.includes(nextLower_qval)) {
              connecting_edge = {
                group: 'edges',
                data:
                  {id: `${rank_qval} to ${nextLower_qval}`, 
                  source: rank_qval, 
                  target: nextLower_qval,
                  type: 'hierarchy: down',
                  label: '',
                  },
              }
              taxonomic_rank_edges.push(connecting_edge)
            }
          }
        }
        // Manipulations to graph
        cy.add(taxonomic_rank_edges);

        // Change rank layout to cola 
        var rank_layout = cy.nodes(`[type = 'display']`).layout({
          name: 'cola',
          edgeLength: 200,
          avoidOverlap: true,
          nodeSpacing: 180,
          nodeDimensionsIncludeLabels: true,
          alignment: {vertical: [taxonomic_rank_nodes]},
          flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
          handleDisconnected: false,
          centerGraph: false,
          fit: false,
        })
        rank_layout.run();
        // Default view is collapsed view
        api.collapseAll();
    });
    }

    function exec(graphType) {
      let cy_container = document.getElementById("cy");
      cy_container.style.height = "67vh";

      let navDisplayParent = document.getElementById("navigation-history");
      navDisplayParent.innerHTML = "";

      let navButtonsParent = document.getElementById("show-nav-buttons");
      navButtonsParent.innerHTML = "";

      // Exec creates both general hierarchy and also the expandable ranks... 
      let url = hierarchy_query(ROOT_NAME, true);
      d3.json(url).then(function(json_result) {
        display_hierarchy(json_result, graphType, {given_data: 'null', taxon_value: "null"}, "root");
      });

    }

    var cy, api; // These variables defined first, to be accessed later.
    //givenData is an object {given_data: 'null'} if we're not going to be given anything, otherwise
    //{given_data: {...}} where {...} is what convert_to_cytoscape(data) would print out
    function display_hierarchy(data, graphType, givenData, given_taxon) {
        let user_entered_taxon = givenData.taxon_value;
        let converted_data;

        if (givenData.given_data != 'null') { 
          //this implies we are already given what convert_to_cytoscape would produce
             converted_data = givenData.given_data;
        } else {
             converted_data = convert_to_cytoscape(data);
        }
        let root_rank = converted_data.root_rank;
        let root = converted_data.root;
	      let pc_edges = converted_data.pc_edges;
        let definitions = converted_data.definitions;
        let taxon_qvals = converted_data.taxon_qvals;
        let parent_and_all_children = {...(converted_data.parent_and_all_children)};
        //of the form where keys are qvals and values are the taxon names
        let graphType_pc_edges = {...pc_edges};


        let all_ranks = [
        'Subkingdom', 'Phylum', 'Subphylum', 'Infrakingdom', 
        'Superphylum', 'Class', 'Subclass', 'Infraclass', 'Superorder', 
        'Order', 'Suborder', 'Family', 'Genus', 'Species', 'Superfamily', 
        'Subfamily', 'Infraorder', 'Tribe', 'Subgenus', 'Subtribe', 
        'Infraphylum', 'Superclass', 'Kingdom'];

        
        let concise_ranks = [root_rank,
         'Phylum', 'Class', 'Order', 'Family', 
         'Genus', 'Species', 'Tribe', 'Kingdom', 'no_rank'];

        if (graphType == ('Concise')) {
            new_data = create_graphType(converted_data, concise_ranks, user_entered_taxon);
            nodes_lst = new_data.nodes;
            edge_lst = new_data.edges;
            graphType_pc_edges = new_data.newPC_edges;
            parent_and_all_children = {...(new_data.graphType_parent_and_all_children)};

        } else if (graphType == ('Moderate')) {
            new_data = create_graphType(converted_data, all_ranks, user_entered_taxon);
            nodes_lst = new_data.nodes;
            edge_lst = new_data.edges;
            graphType_pc_edges = new_data.newPC_edges;
            parent_and_all_children = {...(new_data.graphType_parent_and_all_children)};

        } else {
          nodes_lst = converted_data.nodes;
          edge_lst = converted_data.edges;
        }

        console.log('graph type parent and all kids in display hierarchy', parent_and_all_children, 'graph type', graphType);

        const cyDiv = document.querySelector('#cy');
        cyDiv.style.display = 'block';        

        // variable cy should be able to be accessed everywhere, but the definition if awkward because it only happens after the display function is called. 
        cy = cytoscape({
            container: document.getElementById('cy'),
            nodeDimensionsIncludeLabels: true,
            elements: {
              nodes: nodes_lst,
              edges: edge_lst
            },
            layout: {
              name: 'dagre', 
              spacingFactor: 4,
              rankDir: 'BT',
              avoidOverlap: true,
              nodeRepulsion: function( node ){ return 2048; },
            },
            wheelSensitivity: 0.4,
            style: [
              {
                selector: 'node[name]',
                  style: {
                      'content': 'data(name)',
                      'text-valign': 'center',

                }

            },
            {
              selector: 'node',
              style: {
                'width': 'data(width)',
                'height': 'data(height)',
                'font-size': 30,
                'background-color': 'data(color)'
              }
            },
            {
              selector: ":parent",
              style: {
                "background-color": "#D4D260",
                "background-opacity": 0.5,
                "border-width": 4,
                "border-color": 'black',
                "text-valign": 'top',
                "font-size": 50,
                "font-weight": 'bold',
                "color": '#33640D'
              }
            },
            {
              selector: 'edge',
              style: {
                  'curve-style': 'bezier',
                  'target-arrow-shape': 'triangle',
                  'label': 'data(label)',
                  'font-size': 27,
                  'width': 10

                }
            },
            {
              selector: `edge[type = "hierarchy: up"]`,
              style: {
                'curve-style': 'straight',
                'target-label': 'nextHigherRank',
                'target-text-offset': 145,
                'opacity': 0.8,
              },
            },
            {
              selector: `edge[type = "hierarchy: down"]`,
              style: {
                'curve-style': 'unbundled-bezier',
                'control-point-distances': -200,
                'control-point-weights': 0.5,
                'target-label': 'nextLowerRank',
                'target-text-offset': 155,
                'opacity': 0.8,
              },
            },
            {
              selector: '.eh-handle',
                style: {
                  'background-color': 'red',
                  'width': 12,
                  'height': 12,
                  'shape': 'ellipse',
                  'overlay-opacity': 0,
                  'border-width': 12, // makes the handle easier to hit
                  'border-opacity': 0
                }
            },
            {
              selector: ':selected',
              style: {
                "border-width": 2,
                "border-color": "rgb(1,105,217)"
              }
            },
            // Styles for all different types
            {
              selector: 'node[type = "literal"]',
              style: {
                'shape': 'square',
                'background-color': '#FFD580',
                'text-wrap': 'wrap',
                'text-max-width': 343,
                'border-width': 5,
                'border-color': '#FFA500',
                'border-style': 'solid',
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              }
            },
            {
              selector: 'node[type = "subTaxProp"]',
              style: {
                'text-wrap': 'wrap',
                'text-max-width': 230,
                'border-width': 5,
                'border-color': '#00008B',
                'border-style': 'solid',
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              }
            },
            {
              selector: 'node[type = "image"]',
              style: {
                'shape': 'rectangle',
                'background-color': 'white',
                'font-size': 0,
              }
            },
            {
              selector: `node[type = "property definition"]`, 
              style: {
                'shape': 'square',
                'background-color': '#FFD580',
                'text-wrap': 'wrap',
                'text-max-width': 280,
                'border-width': 5,
                'border-color': '#FFA500',
                'border-style': 'solid',
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              }
            },
            {
              selector: `node[type = "concept"]`, 
              style: {
                'width': 250,
                'height': 250,
                'background-color': '	#FFB52E',
                'text-wrap': 'wrap',
                'text-max-width': 100,
                'border-width': 5,
                'border-color': '#F6BE00',
                'border-style': 'solid',
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              }
            },
            {
              selector: `node[type = "bnode"]`, 
              style: {
                'shape': 'ellipse',
                'background-color': '#CBC3E3',
                'text-wrap': 'wrap',
                'text-max-width': 280,
                'border-width': 5,
                'border-color': '#301934',
                'border-style': 'solid',
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              }
            },
            { selector: `node[type = "overlay hierarchy"]`,
              style: {
              'text-wrap': 'wrap',
              'text-max-width': 100,
              'border-width': 5,
              'border-color': '#228B22',
              'border-style': 'solid',
              'font-size': 35,
              'font-family': 'Calibri',
              'line-height': 1.15
              }
            },
            { selector: `node[type = "uri"]`,
              style: {
              'text-wrap': 'wrap',
              'text-max-width': 100,
              'font-size': 35,
              'font-family': 'Calibri',
              'line-height': 1.15,
              'width': 150,
              'height': 150
              }
            },
            {
              selector: `node[type = 'display']`,
              style: {
                'text-wrap': 'wrap',
                'text-max-width': 100,
                'font-size': 35,
                'font-family': 'Calibri',
                'line-height': 1.15
              }
            }
          ]
        });

        // Updating layout dimensions setting to avoid overlap
        var options = {
        nodeDimensionsIncludeLabels: true // boolean which changes whether label dimensions are included when calculating node dimensions, default true
        };
        var dims = cy.nodes().first().layoutDimensions(options);

        // Initialize navigator
        var defaults = {
          container: false, 
          viewLiveFramerate: 0,
          thumbnailEventFramerate: 30,
          thumbnailLiveFramerate: false,
          dblClickDelay: 200, // milliseconds
          removeCustomContainer: true, // destroy the container specified by user on plugin destroy
          rerenderDelay: 100, // ms to throttle rerender updates to the panzoom for performance
        };
        // Navigation not rendering well, so skip for now. 
        // var nav = cy.navigator(defaults); // get navigator instance, nav

        // Initializing the expansaion of frames 
        cy.expandCollapse({
          // layoutBy: {
          //   name: "cola",
          //   rankDir: 'BT',
          //   animate: false,
          //   fit: false,
          // },
          fisheye: false,
          animate: true,
          undoable: false,
          fit: false,
          expandCueImage: "external/icon-plus.png",
          collapseCueImage: "external/icon-minus.png",
          avoidOverlap: true,
        });
        api = cy.expandCollapse('get');

        // Handle the close all button
        document.getElementById("Collapse").addEventListener("click", function () {
          api.collapseAll();
        });

        // CONTEXT MENU
        contextMenu = cy.contextMenus({
          menuItems: [
            {
              id: 'copyURL',
              content: 'Copy Image Address',
              selector: 'node[type = "image"]',
              onClickFunction: function (event) {
                let target = event.target;

                navigator.clipboard.writeText(target.data('href'));

                // Tooltip confirmation
                target.popperref = event.target.popper({
                  content: () => {
                    tips.innerHTML = "<p>URL Copied!</p>";
                    tips.style =
                      "background-color: #949494; color: #fff; text-align: left; padding: 2px 4px; border-radius: 3px; font-size:10px;";
                    tips.className = "tooltiptext";
                    document.body.appendChild(tips);
                    setTimeout(function() {
                        document.body.removeChild(tips);
                    }, 1500);
                    return tips;
                  },
                  popper: {
                    placement: "top-start",
                    removeOnDestroy: true
                  }
                })
              },
              hasTrailingDivider: true
            },
            {
              id: 'copyImage',
              content: 'Copy Image',
              tooltipText: 'Copy Image',
              selector: 'node[type = "image"]',
              hasTrailingDivider: true,
              onClickFunction: function (event) {
                let target = event.target;
                let url = target.data('href');
                CopyImageClipboard.copyImageToClipboard(
                  url,
                )
                  .then(() => {
                    console.log('Image Copied')
                  })
                  .catch((e) => {
                    console.log('Error: ', e.message)
                  })
                // Tooltip confirmation
                target.popperref = event.target.popper({
                  content: () => {
                    tips.innerHTML = "<p>Image Copied!</p>";
                    tips.style =
                      "background-color: #949494; color: #fff; text-align: left; padding: 2px 4px; border-radius: 3px; font-size:10px;";
                    tips.className = "tooltiptext";
                    document.body.appendChild(tips);
                    setTimeout(function() {
                        document.body.removeChild(tips);
                    }, 1500);
                    return tips;
                  },
                  popper: {
                    placement: "top-start",
                    removeOnDestroy: true
                  }
                })
              },
            },
            {
              id: 'saveImage',
              content: 'Save image',
              selector: 'node[type = "image"]',
              coreAsWell: true,
              show: true,
              hasTrailingDivider: true,
              onClickFunction: function (event) {
                let target = event.target;
                let url = target.data('href')
                function dataToURL(url) {
                    return fetch(url).then((response) => {
                            return response.blob();
                        }).then(blob => {
                            return URL.createObjectURL(blob);
                        });
                }
                async function downloadImage(url) {
                        const a = document.createElement("a");
                        a.href = await dataToURL(url);
                        a.download = url.split("650px-")[1];
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        console.log("Image Downloaded!")
                }
                downloadImage(url)
              }
            },
            {
              id: 'newTab',
              content: 'Open Image in New Tab',
              tooltipText: 'Copy Image',
              selector: 'node[type = "image"]',
              hasTrailingDivider: true,
              onClickFunction: function (event) {
                let target = event.target;
                let url = target.data('href');
                window.open(url)
                
                }
              },
          ]
        });

        
        let rank_edges = converted_data.rn_edges;
        let nodes = cy.elements().nodes();
        let rank_node_id;
        let add_eles = [];
        
        for (let x = 0; x < nodes.length; x++) {
            node_pos = nodes[x].position();
            node_id = nodes[x].data('id');
            let x_pos = node_pos.x ;
            let y_pos = node_pos.y;
            let rank_node = rank_edges[node_id];
            if (rank_node != "no_rank") {

              let rank_node_id = rank_node;
              if (rank_node_id == undefined) {
                rank_node_id = `noRank ${x.toString()}`;
              } else {
                rank_node_id = `${rank_node}: ${x.toString()}`
              }
              
              //rank_node_id is undefined in some places
              cy.nodes(`node[id="${node_id}"]`).data('rank_id', rank_node_id)
              new_node = 
              {
                group: 'nodes',
                data: {
                  id: rank_node_id,
                  color: '#90EE90',
                  name: rank_node,
                  width: 100,
                  height: 100,
                  type: 'rank'
                },
                position: {x: x_pos - 400, y: y_pos}
              };
              
              add_eles.push(new_node);
  
              new_edge = 
                {
                  group: 'edges',
                  data: 
                  { id: node_id.concat(rank_node),
                    source: node_id, 
                    target: rank_node_id,
                    label: 'taxonRank'
                  }
                };
              add_eles.push(new_edge);
        }
        }
        //adding ranks to the graph along with edges
          let eles = cy.add(add_eles);
  
          let prop_node_diam = 300
          let definition_node_size = 600
          cy.zoomingEnabled( true );

          let farthest_second_left_child;
          let farthest_second_left_child_pos;

          //maybe make the zoomed position on the given taxon if there is one.
          if (given_taxon != "root") {

            if (parent_and_all_children[given_taxon] == undefined) {
              farthest_second_left_child = given_taxon;
            } else {
              farthest_second_left_child =  (parent_and_all_children[given_taxon])[0];
            }
            farthest_second_left_child_pos = cy.getElementById(`${given_taxon}`).position()
          } else {
            farthest_second_left_child = (parent_and_all_children[(parent_and_all_children[root])[0]])[0]
            farthest_second_left_child_pos = cy.getElementById(`${farthest_second_left_child}`).position()
          }

          let id_label;
          if (given_taxon == "root") {
            id_label = `[id = '${root}']`;
            given_taxon = root;

          } else {
            id_label = `[id = '${given_taxon}']`;
          }
          cy.nodes(id_label).style('background-color', 'red');

          let id_selector = "node[width = 250]";
          cy.nodes(id_selector).style({
            'text-wrap': 'wrap',
            'text-max-width': 150,
            'font-size': 35,
            'font-family': 'Calibri',
            'line-height': 1.15
          });
      
          let zoomedInOnNode = false;
          let id_lastclicked_node = "";

         
          cy.zoom({
            level: .02, // the zoom level
            position: {x: farthest_second_left_child_pos.x, y: 0}
          });

          let prev_nodes_clicked = [];
          let rank_parity_tap = 'even';
          let expand_rank_parity_tap = 'even';

          let navDisplayParent = document.getElementById("navigation-history");
            navDisplayParent.innerHTML = "";

          let navButtonsParent = document.getElementById("show-nav-buttons");
            navButtonsParent.innerHTML = "";

          show_navigation_history(given_taxon, given_taxon, all_ranks,
          pc_edges, prop_node_diam, graphType_pc_edges, "", taxon_qvals, 
          parent_and_all_children, []);

          //so we want the functionality of the nav buttons to be different from the one when we are in
          //property display mode
          let four_relationships_qvals = display_nav_buttons(given_taxon, graphType_pc_edges, taxon_qvals, parent_and_all_children);
          let relationships = ["nav-down", "nav-left", "nav-right", "nav-up"];
          //relationships needs to be in the same order as is returned by the function display nav buttons
          let idx = 0;
          //adding click events for the navigation buttons
          four_relationships_qvals.forEach(qval => {
            let nodes_lst = [];

            let curr_relationship_id = relationships[idx];
          
            if (qval != " ") {
              document.getElementById(`${curr_relationship_id}`).addEventListener('click', function() {
                  gethierarchy(qval);
              })
            }
            idx +=1;
          });

          cy.on('tap', function(evt) {
            let evtTarget = evt.target;
            let data = evtTarget.data();
            var id = data.id;
            
            if (Object.keys(data).length == 0) {
              if (zoomedInOnNode) {
                return_to_normal(id_lastclicked_node, given_taxon, false, farthest_second_left_child_pos);
                // When we're not displaying the navigation history we want the display height to go back to normal
                let cy_container = document.getElementById("cy");
                cy_container.style.height = "67vh";

                id_lastclicked_node = "";
                zoomedInOnNode = false;
                prev_nodes_clicked = [];
              }
            } else {
              //OTHERWISE WE CLICKED A NODE
                if (data.type == "taxon") {
                  console.log('case: node clicked');
                  let name = data.name;
                  if (!(all_ranks.includes(name))) {
                      cy.nodes(`node[id = "${data.id}"]`).style({
                        'width': 250,
                        'height': 250
                      });
                  //only want to add it to prev nodes clicked if we are moving up not to a sibling or down
                  if (id_lastclicked_node != "") {
                    let curr_pos_y = evtTarget.position()['y']
                    let prev_pos_y = cy.nodes(`[id = "${id_lastclicked_node}"]`).position().y
                    if (curr_pos_y < prev_pos_y) {
                        prev_nodes_clicked.push(id_lastclicked_node);
                    } else {
                      prev_nodes_clicked = [];
                    }
                  }
                  get_properties(given_taxon, data.id, all_ranks, pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, parent_and_all_children, prev_nodes_clicked);
                  zoomedInOnNode = true;
                  id_lastclicked_node = data.id; 
                }
              }
                else if (data.clickable == "true") {
                  console.log('case: data clickable');
                  // If we click on a node that is a display property (one of the nodes part of a ranked subgraph hierarchy), we must make sure that the existing properties and edges are removed.
                  if (data.type == "display") {
                    console.log('case: node is display property');
                    cy.remove(`[class = "property"]`);
                    cy.remove(`[class = "property-edge"]`);
                  }
                
                  // Expandable: true => we want to create a nested node, with this node as the center
                  // Expandable: false => just a normal get properties, with no nesting created
                  let isExpandable;
                  let edge = cy.edges(`[target = "${id}"]`);
                  console.log(edge.json().data);
                  let source = edge.sources();
                  console.log(source.json().data);

                  if (source.length == 1) {
                    isExpandable = "true";
                  }
                  else{
                    isExpandable = "false";
                  }
                  // Call expand function
                  try {
                    get_node_properties(evt, cy.$id(id).data('parent'), isExpandable);
                  }
                  catch(err){
                    console.log(err)
                  }
                }
            }
          });

          // Event listener for context menu taps
          cy.on('cxttap', function(event) {
            let evtTarget = event.target;
            let data = evtTarget.data();
            let id = data['id'];
            if (nested.includes(id) && !cy.$id(id).hasClass('nested')) {
              contextMenu.hideMenuItem(`nodePopOut: ${id}`);
            }
          })
        
          
          // MOUSEOVER STUFF
          // HOVER NODE: reveal definition... This only impacts the large, taxon nodes since those were the only ones that were created as of this point. 
          cy.nodes().on("mouseover",function(evt) {
                var evtTarget = evt.target
                let name = evtTarget.data('name');
                let style = evtTarget.data('style');
                let enlarged_node_size = 275;
                let border_color = '#00008B';
                if ((all_ranks.includes(name))) {
                  enlarged_node_size = 125;
                  border_color = '#013220';
                }
                if (style != undefined) {
                    if (style.opacity == undefined || style.opacity.value == 1) {
                      if (!(all_ranks.includes(name) || name == "Clade")) {
                          get_definition(this.id(), all_ranks, definitions, definition_node_size);
                      }
                    }
                }   
                cy.nodes(`node[id = "${this.id()}"]`).style({
                        'width': enlarged_node_size,
                        'height': enlarged_node_size,
                        'border-width': 1,
                        'border-color': border_color
                });               
            })
          
          .on("mouseout", function(evt) {
            var evtTarget = evt.target
            let id_selector = `node[type = "definition"]`;
            cy.remove(id_selector);

            let reg_node_size = 250;
            let name = evtTarget.data('name');
            if ((all_ranks.includes(name))) {
                reg_node_size = 100
            }
            cy.nodes(`node[id = "${this.id()}"]`).style({
                        'width': reg_node_size,
                        'height': reg_node_size,
                        'border-width': 0,
            });
          });
        
        // Hover over image link: reveal image link 
        let tips = document.createElement("div");
        cy.on('mouseover', 'node[type = "image"]', function(event) {
            let target = event.target;
            target.popperref = event.target.popper({
              content: () => {
                tips.innerHTML = `<a style="color:white;" href='${event.target.data("href")}'>${event.target.data("href")}</a>`;
                tips.style =
                  "background-color: #949494; color: #fff; text-align: left; padding: 6px 8px; border-radius: 4px; font-size:10px;";
                tips.className = "tooltiptext";
                document.body.appendChild(tips);
                return tips;
              },
              popper: {
                placement: "top-start",
                removeOnDestroy: true
              }
            });
          })
          cy.on('mouseout', 'node[type = "image"]', function(event) {           
            tips.style.display = "none";
          });

          // EDGES
          cy.edges().on('mouseover', function(evt) {
            let evtTarget = evt.target;
            let data = evtTarget.data;
            cy.edges(`edge[id = "${data.id}"]`).style({
              'arrow-scale': 5
            })
            
          })
          .on('mouseout', function(evt) {
            let evtTarget = evt.target;
            let data = evtTarget.data;
            cy.edges(`edge[id = "${data.id}"]`).style({
              'arrow-scale': 1
            })
          })
    }

      //changes the buttons for the new input node 
      function change_buttons(new_data, full_json, taxonVal) {
            document.getElementById("Full").onclick = 
                  function () {display_hierarchy(full_json, 'Full', {given_data: new_data, taxon_value: taxonVal}, taxonVal)};

            document.getElementById("Moderate").onclick = 
                  function () {display_hierarchy(full_json, 'Moderate', {given_data: new_data, taxon_value: taxonVal}, taxonVal)};

            
            document.getElementById("Concise").onclick = 
                  function () {display_hierarchy(full_json, 'Concise', {given_data: new_data, taxon_value: taxonVal}, taxonVal)};

      }

    // Transform_data is a function that takes in the query from the new root node and then updates it so that it returns all the nodes above the queried node 
    function transform_data(full_data, full_json, short_json, taxonVal, taxon_qval) {
          
          let short_data = convert_to_cytoscape(short_json);
          let short_pc_edges = short_data.pc_edges;
          let pref_labels = full_data.pref_labels;
          let pc_edges = full_data.pc_edges; //grabs the source-target edges so that we can form new edges and add new nodes
          let root = full_data.root;  //in the form of a qval
          let old_nodes = short_data.nodes;
          let names_to_qvals = full_data.names_to_qvals;
          let qvals_to_names = {...full_data.taxon_qvals};
          let given_taxon_parent_and_all_children = {...(short_data.parent_and_all_children)}
          
          let keeping_track_of_new_edges = short_pc_edges;


          let old_edges = short_data.edges;
          let curr_node = taxon_qval; //in the form of a qval 
          let next_node;

          let old_edges_copy = {...old_edges};


          const MAX_ITER = 5000;
          let iterations = 0;
          
          while (curr_node != root && ++iterations < MAX_ITER ) {

            next_node = pc_edges[curr_node];

            next_node_name = `${qvals_to_names[next_node]} boltz: ${next_node}`;

            let new_node = {
              data: {
                  id: next_node, 
                  name: next_node_name, 
                  color: '#ADD8E6', 
                  width: 250, 
                  height: 250,
                  type: 'taxon'
                }};
            old_nodes.push(new_node);
            
            //only add a new edge if it hasn't already been added
            if ((curr_node!= undefined && next_node != undefined)) {
              if (short_pc_edges[curr_node] == undefined || short_pc_edges[curr_node] == "root") {

                if (given_taxon_parent_and_all_children[next_node] == undefined) {
                      given_taxon_parent_and_all_children[next_node] = [curr_node];
                    } else {
                      if (!given_taxon_parent_and_all_children[next_node].includes(curr_node) ) {
                        given_taxon_parent_and_all_children[next_node].push(curr_node);
                      }
                    }

                let new_edge = {data: {id: curr_node.concat(next_node), 
                  source: curr_node, target: next_node, label: 'subTaxonOf'}};
                  old_edges.push(new_edge);

              }
            }

            curr_node = next_node;
          }
          let new_data = {edges: old_edges, nodes: old_nodes, 
            pc_edges: pc_edges, rn_edges: full_data.rn_edges, 
            root_rank: full_data.root_rank, root: full_data.root, 
            definitions: full_data.definitions, taxon_qvals: full_data.taxon_qvals,
            pref_lables: full_data.pref_labels, parent_and_all_children: given_taxon_parent_and_all_children};
          
          //so we've updated our edges and nodes to include the ones above the root we queried, so 
          //now we want to display the graph.

          
          change_buttons(new_data, full_json, taxon_qval);
          display_hierarchy(full_json, 'Concise', {given_data: new_data, taxon_value: taxon_qval}, taxon_qval);
          document.getElementById("Concise").style.background='green';
          document.getElementById("Full").style.background='black';
          document.getElementById("Moderate").style.background='black';



    }


    function change_to_root() {
          hierarchy_query(ROOT_NAME, false);

          document.getElementById("Full").onclick = 
                function () {exec('Full')};
          
          document.getElementById("Moderate").onclick = 
                function () {exec('Moderate')};

          

          document.getElementById("Concise").onclick = 
                function () {exec('Concise')};

          exec('Concise');
          document.getElementById("Concise").style.background='green';
          document.getElementById("Full").style.background='black';
          document.getElementById("Moderate").style.background='black';


          //removing the back to root button because we don't need it
          //if we're already at the root

          let btn = document.getElementById('changetoRoot_button');
          btn.parentNode.removeChild(btn);
          document.getElementById("hierarchySpecies").value = "";
          let el2 = document.getElementById('error_message');
          if (el2 != null) {
            el2.parentNode.removeChild(el2);
          }

    }

    function gethierarchy_intermediate(full_data_json, taxonVal) {
          let full_data = convert_to_cytoscape(full_data_json);

          let pref_labels = full_data.pref_labels;

          let pc_edges = full_data.pc_edges; //grabs the source-target edges so that we can form new edges and add new nodes
          let names_to_qvals = full_data.names_to_qvals;
          let qvals_to_names = full_data.taxon_qvals;


          let pref_label_of_taxonVal = pref_labels[taxonVal];
          let taxon_qval;

          if (qvals_to_names[taxonVal] != undefined){
            taxon_qval = taxonVal;
            taxonVal = qvals_to_names[taxonVal];
          }else{
            taxon_qval = names_to_qvals[taxonVal];
          }

          if (pref_label_of_taxonVal != undefined) {
            //means we are looking at a pref_label of something
            //and we want taxonVal to now be the taxonName
            taxonVal = pref_label_of_taxonVal;
            taxon_qval = names_to_qvals[taxonVal];
          }
      

          if ((taxon_qval == undefined && pref_label_of_taxonVal == undefined)) {
            //now we want to tell the user they have input something invalid
            let place = document.getElementById("hierarchy-entry");
            let error_message = document.createElement("p");
            error_message.innerHTML = `Concept '${taxonVal}' is not found. Please try again.`;
            error_message.id = "error_message";
            place.appendChild(error_message);
            error_message.style.color = 'red';
            return false;
          }
          

          let short_data_url = hierarchy_query(taxonVal, true);

          //change query back to the root one
          hierarchy_query(ROOT_NAME, false);

          d3.json(short_data_url).then(function(short_data_json) {
            transform_data(full_data, full_data_json, short_data_json, taxonVal, taxon_qval);
          })
      }


      function gethierarchy(given_taxon) {
        let navDisplayParent = document.getElementById("navigation-history");
        navDisplayParent.innerHTML = "";
        
        let navButtonsParent = document.getElementById("show-nav-buttons");
        navButtonsParent.innerHTML = "";
        let hierarchyVal;

        if (given_taxon == "null"){
          let el = document.getElementById('changetoRoot_button');
          if (el != null) {
             el.parentNode.removeChild(el);
          }
  
          let el2 = document.getElementById('error_message');
          if (el2 != null) {
            el2.parentNode.removeChild(el2);
          }
  
          let place = document.getElementById("hierarchy-entry");
          let backtoRoot_btn = document.createElement("button");
          backtoRoot_btn.innerHTML = "Back to Root";
          place.appendChild(backtoRoot_btn);
          backtoRoot_btn.setAttribute('id',"changetoRoot_button");
          backtoRoot_btn.style.backgroundColor = 'salmon';
          backtoRoot_btn.style.width = '100px';
          backtoRoot_btn.style.height = '30px';
         /* backtoRoot_btn.setAttribute('style',"width: 100px")
          backtoRoot_btn.setAttribute('style',"height: 30px")*/
  
  
  
          backtoRoot_btn.className = "change-root-button";
          backtoRoot_btn.type = "button";
          backtoRoot_btn.addEventListener('click', function () {
            change_to_root();
          })
  
  
  
          hierarchyVal = document.getElementById("hierarchySpecies").value;
          if (hierarchyVal.length >= 2) {
              hierarchyVal = capitalize(hierarchyVal);
            }
        } else {
          hierarchyVal = given_taxon;
        }
        //check if a "backtoroot" button exists and if it does get rid of it
        let prevquery = document.getElementById("sparql");
        let old_prevquery = prevquery.value;

        //gets the old url
        let endpoint = d3.select("#endpoint").property("value");
        let sparql = d3.select("#sparql").property("value");
        let full_data_url = endpoint + "?query=" + encodeURIComponent(sparql); 
        
          prevquery.innerHTML = old_prevquery;
          document.getElementById("hierarchySpecies").value = "";

          d3.json(full_data_url).then(function(full_data_json) {
            gethierarchy_intermediate(full_data_json, hierarchyVal)
          });
      }

      // All hover functionalities + event listeners of nodes. 


    </script>
  </head>


  <body>


    <div id="query" style="margin: 10px">
      <h1 class="title">Knowledge Graph Query and Display</h1>
        <div class="input-append">
          <input id="endpoint" class="span5" value="http://solid.boltz.cs.cmu.edu:3030/Devel/sparql" type="text" style="display:none;">
          <div id="show-nav-buttons">
          </div>
          
          <div class="graph-type-btns">
            <button id="Full" class="btn" type="button" onclick="exec('Full')">Full</button>
            <button id="Moderate" class="btn" type="button" onclick = "exec('Moderate')">Moderate</button>
            <button id="Concise" class="btn2" type="button" onclick = "exec('Concise')">Concise</button>  
            <button id="Collapse" class="btn2" type="button">Collapse All</button>  

          </div>
         
          <div id ="hierarchy-entry">
            <input id="hierarchySpecies" class="input-species" placeholder="Enter Taxon Name">
          </div>
    
          <div id ="navigation-history" class="nav-history">
          </div>
  
        </div> 
      <textarea id="sparql" class="spans9" style="display:none;"></textarea>

      <input id="endpoint2" class="span6" value="http://solid.boltz.cs.cmu.edu:3030/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql2" class="spans10" style="display:none;"></textarea>

      <input id="endpoint3" class="span6" value="http://solid.boltz.cs.cmu.edu:3030/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql3" class="spans10" style="display:none;"></textarea>

      <input id="endpoint4" class="span6" value="http://solid.boltz.cs.cmu.edu:3030/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql4" class="spans10" style="display:none;"></textarea>

      <input id="endpoint5" class="span6" value="http://solid.boltz.cs.cmu.edu:3030/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql5" class="spans10" style="display:none;"></textarea>

      <input id="endpoint6" class="span6" value="http://solid.boltz.cs.cmu.edu:3030/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql6" class="spans10" style="display:none;"></textarea>

      
    </div>
    <div>
      <div id="cy">
      </div>
    </div>

    <script>
      window.onload = exec('Concise');
      let fullButton = document.querySelector('#Full');
      let conciseButton = document.querySelector('#Concise');
      let moderateButton = document.querySelector('#Moderate');


      fullButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = 'green')

      fullButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = '#000000')

      fullButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = '#000000')
      

      conciseButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = 'green')

      conciseButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = '#000000')

      conciseButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = '#000000')


      moderateButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = 'green')

      moderateButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = 'black')

      moderateButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = '#000000')
      

      let taxonSpecies = document.getElementById("hierarchySpecies");
        taxonSpecies.addEventListener("keydown", function (e) {
          if (e.key == "Enter") {
            gethierarchy("null");
          }
        });

    </script> 
      
  </body>
</html>
