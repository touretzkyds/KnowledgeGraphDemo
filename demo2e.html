<!DOCTYPE html>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<html>
  <head>
    <script src="external/d3.v7.min.js"></script>
    <script src="external/cytoscape.min.js"></script>

    <script src="external/dagre.js"></script>
    <script src="external/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2/dist/umd/popper.js"></script>
    <script src="external/cytoscape-popper/cytoscape-popper.js"></script>
    <script src="external/cytoscape-context-menus/cytoscape-context-menus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/copy-image-clipboard/dist/index.browser.js"></script>



    <style type="text/css">
      .body{
        margin: 0;
      }

      #cy {
        display: none;
        height: 67vh;
        margin-top:30px;
        width: 100%;
        border-style: solid;
      }

      #cy2 {
        display: none;
        visibility: hidden;
        top: 30px;
        height: 40vh;
        width: 40vh;
        border-style: solid;
      }

      #navigation-history{
        max-width: 100%;
        display: inline-block;
      }
 
      .title {
        text-align: center;
      }
      
      #nav-up,
      #nav-down,
      #nav-left,
      #nav-right{
        border-radius: 50px;
        background-color: white;
        font-weight: 600;
        width: 140px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }

      #middle-nav{
        border-radius: 50px;
        background-color: #f08080;
        border: 0px;
        font-weight: 600;
        width: 130px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }
  

      .btn {
        background-color: black;
        color: white;
        padding: 10px;
        width: 100px;
      }



      .btn2 {
        background-color: green;
        color: white;
        padding: 10px;
        width: 100px;
      }

      .input-species {
        background-color: white;
        color: black;
        margin-top: 20px;
        margin-bottom: 20px;
        margin-right: 5px; 
        height: 20px;
        width: 150px;
      }

      .hierarchy-entry-button {
        background-color: white;
        margin-top: 20px;
        margin-bottom: 20px;
        width: 100px; 
        height: 30px;
      }

      .nav-history{
        display: flex;
      }
      
      /* CONTEXT MENUS */
      .cy-context-menus-cxt-menu {
          display:none;
          z-index: 1000;
          position:absolute;
          border:1px solid #A0A0A0;
          padding: 0;
          margin: 0;
          width:auto;
      }

      .cy-context-menus-cxt-menuitem {
          display:block;
          width: 100%;
          padding: 3px 20px;
          position:relative;
          margin:0;
          background-color:#f8f8f8;
          font-weight:normal;
          font-size: 12px;
          white-space:nowrap;
          border: 0;
          text-align: left;
      }

      .cy-context-menus-cxt-menuitem:enabled {
          color: #000000;
      }

      .cy-context-menus-ctx-operation:focus {
        outline: none;
      }

      .cy-context-menus-cxt-menuitem:hover {
          color: #ffffff;
          text-decoration: none;
          background-color: #fdd3ef;
          background-image: none;
          cursor: pointer;
      }

      .cy-context-menus-cxt-menuitem[content]:before {
          content:attr(content);
      }

      .cy-context-menus-divider {
        border-bottom:1px solid #A0A0A0;
      }

      .cy-context-menus-submenu-indicator {
          position: absolute;
          right: 2px;
          top: 50%;
          transform: translateY(-50%);
      }

      
    </style>

    <script> 

      let my_result;
      let bindings;
      let len;
      let nodes;
      let child;
      let parent;
      let data_obj;

      const ROOT_QVAL = "Q729";
      const ROOT_NAME = "Animalia";

    //takes a string and capitalizes all first letters of the word;
    function capitalize(str) {
        return str.charAt(0).toUpperCase() + (str.toLowerCase()).slice(1);;
    }


    function hierarchy_query(taxon_value, perform_query) {
        const prevquery = document.getElementById("sparql");
        prevquery.innerHTML = 
          `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
           PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
           PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
           PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
           PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
           PREFIX qudt:  <http://qudt.org/schema/qudt/>
           PREFIX unit:  <http://qudt.org/vocab/unit/> 
           PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
           PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
           PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
           PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
           PREFIX la: <https://linked.art/ns/terms/>
           PREFIX un: <http://www.w3.org/2007/ont/unit#> 
           PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
           SELECT DISTINCT ?root_name ?root ?root_rank ?parent_name ?parent ?parent_prefLabel
           ?child_name ?child ?child_prefLabel ?def ?root_def ?rank_name
             WHERE { 
               BIND ("${taxon_value}"@en AS ?root_name). 
                 ?root kgo:taxonName ?root_name .  
                 ?root kgo:taxonRank [rdfs:label ?root_rank] .
                 OPTIONAL {
                   ?root skos:definition ?root_def .
                 }
                 ?child kgo:subTaxonOf* ?root . 
                 ?child kgo:subTaxonOf ?parent . 
                 ?child kgo:taxonName ?child_name .
                 OPTIONAL {
                   ?child skos:definition ?def .
                 }
                   ?child kgo:taxonRank ?rank .
                   ?rank rdfs:label ?rank_name . 
                   ?parent kgo:taxonName ?parent_name .
                   ?child skos:prefLabel ?child_prefLabel .
                   ?parent skos:prefLabel ?parent_prefLabel .
             }`

        if (perform_query) {
          const endpoint = d3.select("#endpoint").property("value")
          const sparql = d3.select("#sparql").property("value")
          const url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        } else {
          return false
        }
    }

    function property_query(taxon_value, perform_query) {
      const prevquery = document.getElementById("sparql2");
      prevquery.innerHTML = 
        `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
         PREFIX dc: <http://purl.org/dc/elements/1.1/> 
         PREFIX dcterms: <http://purl.org/dc/terms/>
         PREFIX owl: <http://www.w3.org/2002/07/owl#>
         PREFIX prefix: <http://qudt.org/vocab/prefix/>
         PREFIX prov: <http://www.w3.org/ns/prov#> 
         PREFIX qkdv: <http://qudt.org/vocab/dimensionvector/> 
         PREFIX quantitykind: <http://qudt.org/vocab/quantitykind/> 
         PREFIX sou: <http://qudt.org/vocab/sou/> 
         PREFIX vaem: <http://www.linkedmodel.org/schema/vaem#> 
         PREFIX voag: <http://voag.linkedmodel.org/schema/voag#>
         PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
         PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
         PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
         PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
         PREFIX qudt:  <http://qudt.org/schema/qudt/>
         PREFIX unit:  <http://qudt.org/vocab/unit/> 
         PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
         PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
         PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
         PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
         PREFIX la: <https://linked.art/ns/terms/>
         PREFIX un: <http://www.w3.org/2007/ont/unit#> 
         PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
         SELECT DISTINCT ?pred ?predLabel ?obj ?objLabel ?pred2 ?pred2Label ?list ?obj2 ?obj2Label
           WHERE {
             BIND ( '${taxon_value}' @en AS ?name).
              ?Q skos:prefLabel|kgo:taxonName ?name.
              ?Q ?pred ?obj. 
              OPTIONAL {?Q ?pred [ list:index (?pos ?list) ] }
              OPTIONAL {?Q ?pred ?obj.
                        ?obj ?pred2 ?obj2.
                        OPTIONAL {?pred2 rdfs:label ?pred2Label.}
                        OPTIONAL {?obj2 rdfs:label ?obj2Label.}
                      }
              OPTIONAL { ?pred skos:prefLabel|rdfs:label ?predLabel. } 
              OPTIONAL { ?obj kgo:taxonName|skos:prefLabel|rdfs:label ?objLabel. }
           } ORDER BY ?pred ?pos ?pred2`; 

        
        if (perform_query) {
          const endpoint = d3.select("#endpoint2").property("value")
          const sparql = d3.select("#sparql2").property("value")
          const url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        } else {
          return false
        }

    }

    function box_node_query(taxon_value, perform_query) {
      const prevquery = document.getElementById("sparql3");
      prevquery.innerHTML = 
        `PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
         PREFIX unit:  <http://qudt.org/vocab/unit/>
         PREFIX qudt:  <http://qudt.org/schema/qudt/>
         PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
         PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
         PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
         
         SELECT * WHERE {
          ?taxon kgo:taxonName "${taxon_value}"@en .
          ?taxon ?r ?b.
          ?b rdf:type rdf:List;
             rdf:rest* ?b2.
          ?b2 ?r2 ?v2.
          OPTIONAL { ?v2 skos:prefLabel|rdfs:label ?v2Label. } 
          OPTIONAL { ?r2 skos:prefLabel|rdfs:label ?r2Label. } 

        }`
        if (perform_query) {
          const endpoint = d3.select("#endpoint3").property("value")
          const sparql = d3.select("#sparql3").property("value")
          const url = endpoint + "?query=" + encodeURIComponent(sparql)
          return url
        } else {
          return false
        }
    }


    function rank_property_query(rank_name) {
      const prevquery = document.getElementById("sparql4");
      prevquery.innerHTML = 
        `PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
         PREFIX rdfs:  <http://www.w3.org/2000/01/rdf-schema#> 
         PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
         SELECT DISTINCT ?rank ?rLabel ?nextLower ?nextHigher
          WHERE {
            ?rank rdfs:label "${rank_name}"@en .
            ?rank rdfs:label ?rLabel .
            ?rank kgo:nextLowerRank [ rdfs:label ?nextLower] . 
            ?rank kgo:nextHigherRank [rdfs:label ?nextHigher ].
              
          }
        ORDER BY ?yLabel`;

      const endpoint = d3.select("#endpoint4").property("value");
      const sparql = d3.select("#sparql4").property("value");
      const url = endpoint + "?query=" + encodeURIComponent(sparql);
      return url;
        
    }

    /*convert_to_cytoscape will return an object
    that stores the nodes, the edges, the positions of all
    the nodes, and the ranks for each of the nodes*/
    function convert_to_cytoscape(data) {
        let nodes_lst = [];
        let edges_lst = [];
        let rank_node_edges = {}; //consists of objects that have ranks and nodes that are connected by an edge
        let pc_edges = {};
        let root = 'noRoot';
        let root_rank = "noRank";
        let def_for_taxons = {};
        let node_names = [];

        let qvals_to_names = {};
        let names_to_qvals = {};
        let root_def = "No def";
        let pref_labels = {}; //key is preflable and value is taxon_name
        //need to make edge object based on qvalues and not names

        let parent_and_all_children = {} 
        //going to be an object where the keys are parents and the values are a list of all children

        
        bindings = data.results.bindings;
        len = bindings.length;

        if (len > 0) {
          //we can assume that the first parent is the root for now?
            if (bindings [0].parent_name != undefined &&
                bindings [0].root_rank != undefined &&
                bindings [0].root_def != undefined) {
                  root = bindings [0].parent_name.value;
                  root_rank = bindings [0].root_rank.value;
                  root_def = bindings [0].root_def.value;
                }

                root_qval = bindings [0].parent.value;
                if (root_qval.length >= 40) {
                  root_qval = root_qval.slice(40, root_qval.length);
                }
                names_to_qvals[root] = root_qval
                def_for_taxons[root_qval] = root_def;
                qvals_to_names[root_qval] = root;
            
        }

        /*first we can grab all of the values in our returned json result
        and add them as nodes in alphabetical order. 
        */
        /*so we'll iterate through our json object and
        grab the node names and sort them
        */
        
        
        let root_prefLabel;

        if (root_prefLabel != undefined) {
              let root_prefLabel = capitalize(root_prefLabel);
              if (pref_labels[root_prefLabel] == undefined) {
                pref_labels[root_prefLabel] = root;
              }
        }

        node_names.push({name: root, qval: root_qval});

        for (let i = 0; i < len; i++) {
            child_rank = bindings [i].rank_name.value;
            child_def = bindings [i].def.value;
            child_qval = bindings [i].child.value;
            parent_qval = bindings [i].parent.value;
            child_prefLabel = bindings [i].child_prefLabel.value;
            parent_prefLabel = bindings [i].parent_prefLabel.value;
            parent = bindings [i].parent_name.value;
            rank = bindings [i].rank_name.value;
            child = bindings [i].child_name.value;

            //ignore the data if the parent and child qvals are the same

            if (child_qval.length >= 40 && parent_qval.length >= 40) {
              child_qval = child_qval.slice(40, child_qval.length);
              parent_qval = parent_qval.slice(40, parent_qval.length);
            }

            if (child_qval == root_qval) {
              let root_prefLabel = capitalize(child_prefLabel);
              
                        if (pref_labels[root_prefLabel] == undefined) {
                          pref_labels[root_prefLabel] = root;
                        }
            }
            if (parent_qval == root_qval) {

               let root_prefLabel = capitalize(parent_prefLabel);
                        if (pref_labels[root_prefLabel] == undefined) {
                          pref_labels[root_prefLabel] = root;
                        }
            }

            //only want to continue if parent and child qvals are diff and if 
            //we haven't seen the child yet
            if (child_qval != parent_qval && qvals_to_names[child_qval] == undefined) {

                      node_names.push({name: child, qval: child_qval});

                      def_for_taxons[child_qval] = child_def;
                      qvals_to_names[child_qval] = child;

                      if (names_to_qvals[child] != undefined) {
                        names_to_qvals[`${child}: ${rank}`] = child_qval;
                      } else {
                        names_to_qvals[child] = child_qval;
                      }
                      //because the child name can be repeated


                      if (child_prefLabel != undefined) {
                        child_prefLabel = capitalize(child_prefLabel);
                        if (pref_labels[child_prefLabel] == undefined) {
                          pref_labels[child_prefLabel] = child;
                        }
                      }
                      pc_edges[child_qval] = parent_qval; //source is the key and target is the value
                      rank_node_edges[child_qval] = rank;

                      
                      
            }

        }
        node_names = node_names.sort(function(a, b) {
            let keyA = a.name;
            let keyB = b.name;
            // Compare the 2 dates
            let result = keyA.localeCompare(keyB);
            return result;
          });
        

        for (let idx = 0; idx < node_names.length; idx++) {
          curr_name = node_names[idx].name;
          curr_qval = node_names[idx].qval;
         
          node_obj = {
              data: {id: curr_qval, 
              name:`${curr_name} boltz: ${curr_qval.toString()}`,
              color: '#ADD8E6', 
              width: 250, 
              height: 250,
              type: 'taxon'
            }};
            nodes_lst.push(node_obj);



          if (curr_name != ROOT_NAME) {
            parent_qval = pc_edges[curr_qval];
            parent_name = qvals_to_names[parent_qval];

            if (curr_qval != undefined && parent_qval != undefined) {

                    rank = rank_node_edges[curr_qval];
                    if (parent_and_all_children[parent_qval] == undefined) {
                        parent_and_all_children[parent_qval] = [curr_qval];
                    } else {
                      parent_and_all_children[parent_qval].push(curr_qval);
                    }
                            

                  pc_edge = {data: {id: `${curr_qval} - ${parent_qval}`, 
                      source: curr_qval, target: parent_qval, label:'subTaxonOf'}};
                    
                    edges_lst.push(pc_edge); 

                      
                    
            }
            
          }

        }



        pc_edges[root_qval] = 'root';
        rank_node_edges[root_qval] = root_rank;


        return {nodes: nodes_lst, edges: edges_lst, 
          rn_edges: rank_node_edges, pc_edges: pc_edges, 
          root_rank: root_rank, root: root_qval, definitions: def_for_taxons, 
          taxon_qvals: qvals_to_names, pref_labels: pref_labels, 
          names_to_qvals:names_to_qvals, parent_and_all_children: parent_and_all_children};
    }



    //graphType letiable is used to keep track of if the Full or Concise button was pressed

    function find_new_target(old_target, rn_edges, pc_edges, correct_ranks, user_entered_taxon) {
        //pc_edges is an object where the sources are keys and the values are the targets
        let curr_source = old_target;
        let curr_target = pc_edges[curr_source];
        let is_valid_rank = correct_ranks.includes(rn_edges[curr_target]);

        while (!is_valid_rank && curr_target != user_entered_taxon && curr_target != undefined) {

           curr_source = curr_target; //idea is to keep "climbing up" this tree
           //assumption is that curr_source is never going to be undefined
          
           curr_target = pc_edges[curr_source];
           is_valid_rank = correct_ranks.includes(rn_edges[curr_target]);
        }

        if (curr_target == undefined){
          curr_target = ROOT_QVAL //if for some reason we can't find a target then we can just
          //assign the target to the root for now
        }

        return curr_target;
    }
    
    /*so we're given the original nodes and edges and we want to output new nodes/edges
    such that there are only nodes with ranks: correct_ranks.
    if a user enters a taxon in the textbox we automatically want to keep this value
    all missing edges are filled in, also will want to return the rn_edges */
    function create_graphType(data, correct_ranks, user_entered_taxon) {

        let nodes = data.nodes;
        let edges = data.edges;
        let rn_edges = data.rn_edges;
        let pc_edges = data.pc_edges;  //keys are sources and values are targets
        let root = data.root;
        
        let new_edges = [];
        let new_nodes = [];
        let edges_missing = {}; //keeps track of the nodes that now no longer have edges because of the removed ranks
        let taxon_qvals = data.taxon_qvals;

        let graphType_pc_edges = {};
        let node_names = [];  
        let graphType_parent_and_all_children = {};
        let tracking_node_qvals = {};

        //iterating through all the edges and figuring out which ones are going to be removed 
        for (let i = 0; i < edges.length; i++) {

              curr_edge = edges[i];  //of the form: {id: __, source: '', target: '', ...}
              source_node = curr_edge.data.source; //qval
              target_node = curr_edge.data.target; //qval
              keep_source = correct_ranks.includes(rn_edges[source_node]);
              keep_target = correct_ranks.includes(rn_edges[target_node]);
              
              //taking care of the case when a user enters a taxon into the text box
              if (source_node == user_entered_taxon) {
                keep_source = true;
              }
              else if (target_node == user_entered_taxon) {
                keep_target = true;
              }

              if (keep_source && tracking_node_qvals[source_node] == undefined) {
                node_names.push({name: taxon_qvals[source_node], qval: source_node});
                tracking_node_qvals[source_node] = "yes";
                //node_names.push(source_node);
              }
              if (keep_target && tracking_node_qvals[target_node] == undefined) {
                node_names.push({name: taxon_qvals[target_node], qval: target_node});
                tracking_node_qvals[target_node] = "yes";
                //node_names.push(target_node);
              }

              if (!keep_source && !keep_target) {
                  //this means both the target and the source node aren't going to be added
                  let count = "pass";

              } else if (!keep_source || !keep_target)  {
                  //adding missing: "target" regardless, b/c that's what we want to prioritize
                  //and only adding missing: "source" if the em object doesn't already have something there
                              if (!keep_source) {
                                //target_node is valid source_node is going to be removed
                              
                                if (edges_missing[target_node] == undefined) {
                                    new_obj = {
                                        missing: "source",
                                        old_edge: curr_edge,       
                                    };
                                    edges_missing[target_node] = new_obj;
                                    //we know source_node is attached to a valid rank from else clause
                                }
                                  
                              }

                              if (!keep_target) {
                                  new_obj = {
                                      missing: "target",                
                                      old_edge: curr_edge               
                                  };
                                  edges_missing[source_node] = new_obj;
                              }

              } else {
                //we are keeping both the source and target nodes so the original edge
                graphType_pc_edges[source_node] = target_node;
              }

         }
        //at this point don't really need to add anymore nodes
        for (node in edges_missing) {
            curr_data = edges_missing[node]  ;
            //of the form {missing: "source/target", old_edge: {id: , source:, target: }}

            //don't need to worry about curr_data.missing source 
            
            if (curr_data.missing == 'target') {
                old_target = curr_data.old_edge.data.target; //qval
                curr_source = curr_data.old_edge.data.source; //qval
                //now we want to find a new target
                new_target = find_new_target(old_target, 
                rn_edges, pc_edges, correct_ranks, user_entered_taxon);

                graphType_pc_edges[curr_source] = new_target;
            }
        }
        //sort the node names in alphabetical order
        
        node_names = node_names.sort(function(a, b) {
            let keyA = a.name;
            let keyB = b.name;
            // Compare the 2 node names
            let result = keyA.localeCompare(keyB);
            return result;
          });
        
        //this will be used to keep track of the qvals we see to 
        //make sure we aren't adding multiple instances of the same node
        
        //let tracking_target_qvals = []
        //should now be sorted in alphabetical order
        for (let i = 0; i < node_names.length; i++) {
              source_node_qval = node_names[i].qval;
              source_node_name = node_names[i].name;
              target_node_qval = graphType_pc_edges[source_node_qval];
              target_node_name = taxon_qvals[target_node_qval];
              if (source_node_qval != `${root}`) {
                source_node_name = `${source_node_name} boltz:${source_node_qval}`;
                target_node_name = `${target_node_name} boltz:${target_node_qval}`;
                
                let node_width;
                let node_height;

                if (source_node_qval[0] != `Q`) {
                   node_width = 0;
                   node_height = 0;
                } else {
                   node_width = 250;
                   node_height = 250;
                }
                //need this because we are only adding the source nodes because the target
                //nodes will eventually be taken care of except for Animalia which doesn't have a target node
                new_nodes.push({
                  data: {
                    id: source_node_qval, 
                    name: source_node_name, 
                    color: '#ADD8E6', 
                    width: node_width, 
                    height: node_height,
                    type: 'taxon'
                }});
                if (target_node_qval == `${root}`) { //Q2382443 is the Biota Qval
                  new_nodes.push({
                      data: {
                        id: target_node_qval, 
                        name: target_node_name, 
                        color: '#ADD8E6', 
                        width: 250, 
                        height: 250,
                        type: 'taxon'
                      }});
                }
                if (source_node_qval != undefined && target_node_qval != undefined) {
                    
                    if (graphType_parent_and_all_children[target_node_qval] == undefined) {
                      graphType_parent_and_all_children[target_node_qval] = [source_node_qval];
                    } else {
                      if (!graphType_parent_and_all_children[target_node_qval].includes(source_node_qval) ) {
                        graphType_parent_and_all_children[target_node_qval].push(source_node_qval);
                      }
                    }

                    new_edge = {data: {id: `${source_node_qval} - ${target_node_qval}`, 
                    source: source_node_qval, target: target_node_qval, label:'subTaxonOf'}};
                    new_edges.push(new_edge);
                }
              }
              

        }

      
        return {nodes: new_nodes, 
                edges: new_edges, 
                em: edges_missing,
                newPC_edges: graphType_pc_edges,
                graphType_parent_and_all_children: graphType_parent_and_all_children};


    }
      //when a specific node is clicked,i.e. node_name
      //all other nodes and edges become transparent
      function shade_other_nodes(node_qval, cy_graph, id_lastclicked_node) {
          cy_graph.elements().nodes().style( { 'opacity' : '.2', 'text-opacity':0 });

          
          if (id_lastclicked_node != "") {
              let id_label = `[id = '${id_lastclicked_node}']`;
              cy_graph.nodes(id_label).style({
                "background-color": "#ADD8E6",
                'border-width': 0
              });
            }
          
          cy_graph.elements().edges().style( { 'line-opacity' : '.2', 'text-opacity':'0' });

          let id_label = `[id = '${node_qval}']`;
    
          cy_graph.nodes(id_label).style({
                      'border-color': '#FFB6C1',
                      'text-opacity': '1',
                      'opacity': '1',
                      'text-wrap': 'wrap',
                      'text-max-width': 125,
                      'border-width': 5,
                      'border-style': 'solid',
                      'font-size': 30,
                      'font-family': 'Calibri',
                      'line-height': 1.15
          });
          
      }




      /*takes in an array of objects from a property query
      and outputs a new array that eliminates redundancy*/
      function trim_prop_query(property_array) {
        //we are going to be looking for a repeat of objLabel and predLabel
        let pred_labels = [];
        let new_property_array = [];
        let obj_label;
        let curr_data_val;
        let bnode_num;
        let bnode_obj;
        let obj2_value;

        //also don't want to count a bnode as multiple nodes
        let bnodes = {};
        let bnode_obj_values = [];
        let curr_bnode_num = 'b0';
        let subtax_rank = {};

        subtax_rank['subtax_identifier'] = "";
        

        for (let i = 0; i < property_array.length; i++) {
            curr_data_val = property_array[i];
            //first check if we have a bnode, if we do automatically add it to our array
            if (curr_data_val.obj != undefined &&
                curr_data_val.obj.type == 'bnode') {
                    
                    bnode_num = curr_data_val.obj.value;
                    if (bnode_num != curr_bnode_num) {
                      //we are now at a diff bnode_num so reset bnode_obj_values
                      //purpose of this is to avoid repeated data in the bnode_objs
                      //that are going to be returned
                      bnode_obj_values = [];
                      curr_bnode_num = bnode_num;
                    }

                    bnode_obj = {};

                    if (curr_data_val.pred2 != undefined 
                      && curr_data_val.obj2 != undefined) {
                            
                            //first need to check that this node_value isn't already added
                            obj2_value = curr_data_val.obj2.value;
                            if (!(bnode_obj_values.includes(obj2_value))) {
                                  bnode_obj = {pred2: curr_data_val.pred2.value,
                                  obj2: obj2_value,
                                  pred2Label: curr_data_val.pred2Label,
                                  obj2Label: curr_data_val.obj2Label};

                                  if (bnodes[bnode_num] == undefined) {
                                    bnodes[bnode_num] = [bnode_obj];
                                    new_property_array.push(curr_data_val);
                                  } else {
                                    bnodes[bnode_num].push(bnode_obj);
                                  }

                                  bnode_obj_values.push(obj2_value);

                            }
                            
                    }      

            }
            
            else if (curr_data_val.objLabel != undefined && curr_data_val.predLabel != undefined) {
              

                obj_label = curr_data_val.objLabel.value;
                pred_label = curr_data_val.predLabel.value;

                if (!(pred_labels.includes(pred_label))) {

                    if (curr_data_val.predLabel != undefined) {
                      if (curr_data_val.predLabel.value == 'subTaxonOf' && subtax_rank['subtax_identifier'] == "") {

                        subtax_rank['subTaxonOf'] = obj_label;

                        let qval_url = curr_data_val.obj.value;

                            if (qval_url.length >= 40
                                && (qval_url.slice(0, 40)) == 'http://solid.boltz.cs.cmu.edu:3030/data/') {
                                subtax_name = `${obj_label}    boltz: ${qval_url.slice(40, qval_url.length)}`;
                                subtax_rank['subtax_identifier'] = subtax_name;
                            }
                      }
                      else if (curr_data_val.predLabel.value == 'taxonRank') {
                        subtax_rank['taxonRank'] = obj_label;

                      } else {
                        new_property_array.push(curr_data_val);
                      }
                      
                    }
                }
                pred_labels.push(pred_label);

            } else {
              new_property_array.push(curr_data_val);
            }

        }

        return {prop_array: new_property_array, bnodes_obj: bnodes, subtax_rank: subtax_rank};
        

      }
      
      //takes care of the functionality after clicking the b4 node
      function add_b5_node(b4_node_id, b4_node_pos, rest_of_prefs, cy_graph, diam) {
          let b4_x = b4_node_pos.x;
          let b4_y = b4_node_pos.y;
          let first_node_id = 'b4 first prop';
          let b5_node_id = 'b5';
          let b5_x = b4_x - 175
          let b5_y = b4_y - 150
          //let first_comp = rest_of_prefs.shift();
          let first_comp = rest_of_prefs[0];
          let first_node = 
                    {
                        group: 'nodes',
                        data: {
                          id: first_node_id,
                          color: '#FFD580',
                          name: first_comp,
                          opacity: 1,
                          width: diam,
                          height: diam,
                          type: `b4 property`
                        },
                        position: {x: b4_x - 175, y: b4_y + 150}
                    };
          cy_graph.add([first_node]);
          let new_edge = 
                    {
                      group: 'edges',
                      data: 
                          {
                              id: b4_node_id.concat(first_node_id),
                              source: b4_node_id, 
                              target: first_node_id,
                              label: 'first'
                          }
                        };
          cy_graph.add([new_edge]);
          
          //let b5_node_name = `b5: [${rest_of_prefs.shift()}]`;
          let last_val = rest_of_prefs[1]
          let b5_node_name = `b5: [${last_val}]`;

          let b5_node = 
                    {
                        group: 'nodes',
                        data: {
                          id: b5_node_id,
                          color: '#FFD580',
                          name: b5_node_name,
                          opacity: 1,
                          width: diam,
                          height: diam,
                          type: `b4 property`
                        },
                        position: {x: b5_x, y: b5_y}
                    };
          cy_graph.add([b5_node]);
          new_edge = 
                    {
                      group: 'edges',
                      data: 
                          {
                              id: b4_node_id.concat(b5_node_id),
                              source: b4_node_id, 
                              target: b5_node_id,
                              label: 'rest'
                          }
                        };
          cy_graph.add([new_edge]);
          let id_selector = `node[type = 'b4 property']`;
              cy_graph.nodes(id_selector).style({
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': diam - 10,
                      'border-width': 3,
                      'border-color': '#301934',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
              });
              cy_graph.elements().edges().style({'font-size': '30'});

          let id_label = `[id = '${b5_node_id}']`;
          let parity_of_tap = 'even'
          cy_graph.nodes(id_label).on('click', function(evt) {

              let data = evt.target._private.data;
              if (parity_of_tap == 'even') {
                cy_graph.add([
                  {group: 'nodes', data: {id: 'b5 first prop', color:'#FFD580',
                  name: last_val, width: diam, height: diam, type: 'b5 property'},
                  position: {x: b5_x -175, y: b5_y + 175}}]);
                cy_graph.add([
                  {group: 'nodes', data: {id: 'empty list', color:'#FFD580',
                  name: '[]', width: diam, height: diam, type: 'b5 property'},
                  position: {x: b5_x -175, y: b5_y - 175}}]);
                cy_graph.add([
                  {group: 'edges',data: {
                              id: b5_node_id.concat('b5 first prop'),
                              source: b5_node_id, 
                              target: 'b5 first prop',
                              label: 'first'
                          }}
                        ]);
                cy_graph.add([
                  {group: 'edges',data: {
                      id: b5_node_id.concat('empty list'),
                      source: b5_node_id, 
                      target: 'empty list',
                      label: 'rest'
                  }}
                ]);
              let id_selector = `node[type = "b5 property"]`;
              cy_graph.nodes(id_selector).style({
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': diam - 10,
                      'border-width': 3,
                      'border-color': '#301934',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
              });
                cy_graph.elements().edges().style({'font-size': '30'});
                parity_of_tap = 'odd';
                cy_graph.nodes(`[id = "${data.id}"]`).style(
                  {'label': 'b5',
                  'shape': 'hexagon',
                  'background-color': '	#fdfa72',
                  'border-color': '#F6BE00'
                                      
                  });

              } else {

                cy_graph.remove('node[type = "b5 property"]');
                
                cy_graph.nodes(`[id = "${data.id}"]`).style({
                  'label': `b5: [${last_val}]`,
                  'shape': 'ellipse',
                  'background-color': '	#CBC3E3',
                  'border-color': '#301934',
                  'border-style': 'solid'
                });
                parity_of_tap = 'even';
              }
          })

      }


      //box_nodes is just the data of the node
      //bnode_properties is thee object with a list of property nodes
      //bnode_name is going to be the name of the bnode
      function add_values_to_bnode(bnode_name, box_nodes, bnode_properties, cy_graph, 
             padding_amt, taxon_x_pos, taxon_y_pos, b4node_names) {
              
              let diam = 120;
              let bnode_data = box_nodes[bnode_name];
              let bnode_pos = bnode_data.position;
              let x_pos = bnode_pos.x;
              let y_pos = bnode_pos.y;
              

              let old_radius = Math.sqrt(Math.pow(taxon_x_pos - x_pos, 2) 
                                          + Math.pow(taxon_y_pos - y_pos, 2));
             
              let x_dist = taxon_x_pos - x_pos;  //need to do this to pretend that taxon is at an origin

              let bnode_degree = Math.acos(x_dist/old_radius);
              if (taxon_y_pos > y_pos && bnode_degree <= (.5 * Math.PI)) {
                bnode_degree = (-1 * bnode_degree) + 2* Math.PI;
              }
              //bnode_degree is the degree that the bnode forms with the taxon_value
              
              let added_els = [];

              let num_bnode_props = bnode_properties[bnode_name].length;
              let mult_constant =5;

              let circumference = (num_bnode_props) * diam;
              let radius = circumference / (2* Math.PI);
              let curr_degree = bnode_degree;
              let degree_movement = (2 * Math.PI) / (num_bnode_props);
              //+1 because we want to count the edge as another 'piece'

              let bnode_vals = [];

              let curr_bnode_props = bnode_properties[bnode_name];
              let add_b5 = false;

              for (let i = 0; i < num_bnode_props; i++) {

                    if (i == 0) {
                      new_degree = (curr_degree + (degree_movement/2))% (Math.PI *2);
                    } else {
                      new_degree = (curr_degree + (degree_movement))% (Math.PI *2);
                    }
                    let next_x_pos = x_pos + (radius*mult_constant)*(Math.cos(new_degree));
                    let next_y_pos = y_pos - (radius*mult_constant)*(Math.sin(new_degree));
                    let curr_degree = new_degree;

                    let curr_bnode_prop = curr_bnode_props[i].obj2;
                    let curr_edge_label = curr_bnode_props[i].pred2;

                    if (curr_bnode_props[i].pred2Label != undefined) {
                      curr_edge_label = curr_bnode_props[i].pred2Label.value;
                    }
                    if (curr_bnode_props[i].obj2Label != undefined) {
                      curr_bnode_prop = curr_bnode_props[i].obj2Label.value;
                    }

                    if (curr_bnode_prop == 'b4') {
                      rest_list = b4node_names.full_list.slice(1, b4node_names.full_list.length);
                      curr_bnode_prop = `b4: [${rest_list.join(', ')}]`;
                      add_b5 = true;
                      let b4_node_id = `${curr_bnode_prop} - ${bnode_name}`
                      //so only want to add an onclick function 
                    }
                    let node_id = `${curr_bnode_prop} - ${bnode_name}`;
                    if (curr_bnode_prop != undefined) {  
          
                                  let new_property_node = 
                                            {
                                                group: 'nodes',
                                                data: {
                                                  id: node_id,
                                                  color: '#FFD580',
                                                  name: curr_bnode_prop,
                                                  opacity: 1,
                                                  width: diam,
                                                  height: diam,
                                                  type: `${bnode_name} property`
                                                },
                                                position: {x: next_x_pos, y: next_y_pos}
                                            };
                                    
                                    
                                    added_els.push(new_property_node);

                                   let new_edge = 
                                            {
                                              group: 'edges',
                                              data: 
                                                  {
                                                      id: node_id.concat(bnode_name),
                                                      source: bnode_name, 
                                                      target: node_id,
                                                      label: curr_edge_label
                                                  }
                                            };

                                      added_els.push(new_edge);

                        }

              }

              cy_graph.add(added_els);
              let id_selector = `node[width = ${diam}]`;
              cy_graph.nodes(id_selector).style({
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': diam - 10,
                      'border-width': 3,
                      'border-color': '#301934',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
              });
              cy_graph.elements().edges().style({'font-size': '30'});

              if (add_b5) {
                let id_label = `[id = "${b4_node_id}"]`;
                let parity_of_tap = 'even';
                let len = b4node_names.full_list.length;
                let rest_names = b4node_names.full_list.slice(1,len).join(', ');
                cy_graph.nodes(id_label).on('click', function(evt) {
                      let data = evt.target._private.data;
                      let pos = evt.target._private.position;
                      if (parity_of_tap == 'even') {
                        add_b5_node(data.id, pos, b4node_names.full_list, cy_graph, diam);
                        parity_of_tap = 'odd';
                        cy_graph.nodes(`[id = '${data.id}']`).style({
                           'label': `b4`,
                           'shape': 'hexagon',
                            'background-color': '	#fdfa72',
                            'border-color': '#F6BE00'
                           
                         })
                      } else {
                         cy_graph.remove(`node[type = "b4 property"]`);
                         cy_graph.remove(`node[type = "b5 property"]`);

                         cy_graph.nodes(`[id = '${data.id}']`).style({
                           'label': `b4: [${rest_names}]`,
                           'shape': 'ellipse',
                           'background-color': '#CBC3E3',
                          'border-color': '#301934',
                         });
                         parity_of_tap = 'even';
                      }
                });
              }
    
      }

      
      function add_subtax_rank_nodes(subtax_rank, cy_graph, node_qval, radius, 
            mult_constant, prop_node_diam, pos, graphType_pc_edges,                 
            given_taxon, all_ranks, pc_edges, taxon_qvals, 
            parent_and_all_children, nodes_we_came_from, degree_movement) {
              
            let subtax_node_id= subtax_rank['subTaxonOf'];
            let rank_node_name = subtax_rank['taxonRank'];
            let subtax_node_name = subtax_rank['subtax_identifier'];

            //console.log('graphType_pc_edges in add subtax', graphType_pc_edges);
            //console.log('pc edges in subtax', pc_edges);
          
            let subTaxonOf_degree = 0;
            let taxon_x_pos = pos.x;
            let taxon_y_pos = pos.y;
            let parent_node;
            let old_radius;
            let x_dist;
            let new_parent_pos;
            let node_id;
            let new_subtax_node;
            let new_subtax_edge;
            let id_label;

            if (subtax_node_id != undefined) {
                    
                    
                    parent_node = graphType_pc_edges[node_qval];

                    //first adding the subTaxonOf property node
                    parent_pos= cy_graph.nodes(`node[id = "${parent_node}"]`).position();
                    //getting the original radius of the subTaxonOf node
                    old_radius = Math.sqrt(Math.pow(taxon_x_pos - parent_pos.x, 2) 
                                          + Math.pow(taxon_y_pos - parent_pos.y, 2));
                  
                    x_dist = parent_pos.x - taxon_x_pos;  //need to do this to pretend that taxon is at an origin
                    
                    subTaxonOf_degree = Math.acos(x_dist/old_radius);
                    
                    new_parent_pos = {x: taxon_x_pos + radius * mult_constant * (Math.cos(subTaxonOf_degree)), 
                                          y: taxon_y_pos - radius * (mult_constant * Math.sin(subTaxonOf_degree))
                                        };
                    
                    node_id = `prop ${subtax_node_id}`;
                    new_subtax_node = 
                            {
                                group: 'nodes',
                                data: {
                                  id: node_id,
                                  color: '#ADD8E6',
                                  name: subtax_node_name,
                                  opacity: 1,
                                  width: 250,
                                  height: 250,
                                  type: 'subTaxProp'
                                },
                                position: new_parent_pos
                            };
                    new_subtax_edge = 
                            {
                              group: 'edges',
                              data: 
                                  {
                                      id: node_id.concat(node_qval),
                                      source: node_qval, 
                                      target: node_id,
                                      label: 'subTaxonOf'
                                  }
                            };

                    cy_graph.add([new_subtax_node]);
                    cy_graph.add([new_subtax_edge]);
                    
                    //now we want to add the clickable feature to these subtax_nodes;
                    //so the last_id_clicked is the current taxon
                    //node_id is the subtax node id but we want the query to run on the 'parent_node' id
                    subtax_node_id_label = `[id = "${node_id}"]`;
                    cy_graph.nodes(subtax_node_id_label).on('click', function(evt) {
                        let evtTarget = evt.target;
                        let data = evtTarget._private.data;

                        let navDisplayParent = document.getElementById("navigation-history");
                        navDisplayParent.innerHTML = "";
                        let new_nodes_we_came_from = [...nodes_we_came_from]
                        new_nodes_we_came_from.push(node_qval);
                        console.log('parent node', parent_node)
                          get_properties(given_taxon, parent_node, cy_graph, all_ranks,
                        pc_edges, prop_node_diam, graphType_pc_edges, node_qval, taxon_qvals, 
                        parent_and_all_children,new_nodes_we_came_from);
                         
                    });

                    cy_graph.nodes(subtax_node_id_label).on('mouseover', function(evt) {
                        let evtTarget = evt.target;
                        let data = evtTarget._private.data;

                        let enlarged_node_size = 275;
                        let border_color = '#00008B';
                        
                         
                        cy_graph.nodes(`node[id = "${this.id()}"]`).style({
                                'width': enlarged_node_size,
                                'height': enlarged_node_size,
                                'border-color': border_color
                        });   
                         
                    });
                    
                    cy_graph.nodes(subtax_node_id_label).on("mouseout", function(evt) {
                    
                      let reg_node_size = 250;
                      
                      cy_graph.nodes(`node[id = "${this.id()}"]`).style({
                                  'width': reg_node_size,
                                  'height': reg_node_size,
                      });

                    });
        

                    

            }

            
            //now need to add the rank node
            if (rank_node_name == undefined) {
                return subTaxonOf_degree;
            }
            
            let rank_pos;
            let next_x_pos;
            let next_y_pos;

            if (Math.abs(subTaxonOf_degree - Math.PI)* (180/Math.PI) <= 15) {
                next_x_pos = taxon_x_pos + (radius*mult_constant)*(Math.cos(degree_movement + subTaxonOf_degree));
                next_y_pos = taxon_y_pos - (radius*mult_constant)*(Math.sin(degree_movement + subTaxonOf_degree));
                rank_pos = {x: next_x_pos, y: next_y_pos};
                subTaxonOf_degree = degree_movement + subTaxonOf_degree;

            } else {
                rank_pos = {x: taxon_x_pos - radius * mult_constant, y: taxon_y_pos};
            }

            let rank_node_id = `prop ${rank_node_name}`;
            let new_rank_node = 
                    {
                        group: 'nodes',
                        data: {
                          id: rank_node_id,
                          color: '#90EE90',
                          name: rank_node_name,
                          opacity: 1,
                          width: 150,
                          height: 150,
                          type: 'overlayRank'
                        },
                        position: rank_pos
                    };
             cy_graph.add([new_rank_node]);
             let new_rank_edge = 
                    {
                      group: 'edges',
                      data: 
                          {
                              id: rank_node_id.concat(node_qval),
                              source: node_qval, 
                              target: rank_node_id,
                              label: 'taxonRank'
                          }
                    };
            cy_graph.add([new_rank_edge]);

            // Mouseover Functionality (ranks) to indicate clickability
            cy_graph.on('mouseover', 'node[type = "overlayRank"]', function(event) {
              cy_graph.nodes(`node[id = "${this.id()}"]`).style({
                        'width': 175,
                        'height': 175,
                }); 
            })
            cy_graph.on('mouseout', 'node[type = "overlayRank"]', function(event) {           
              cy_graph.nodes(`node[id = "${this.id()}"]`).style({
                        'width': 150,
                        'height': 150,
                }); 
          });


            //add a click event to the rank node being displayed
            let rank_parity_tap = 'even';
            cy_graph.nodes(`[id = "${rank_node_id}"]`).on('tap', function(evt) {

              if (rank_parity_tap == 'even') {
                get_rank_property_query(rank_node_name, rank_node_id, cy_graph);
                rank_parity_tap = 'odd';
              } else {
                //otherwise remove the property nodes of the current rank
                cy_graph.remove(`node[type = "rank property"]`);
                rank_parity_tap = 'even';
              }
              
            })



            cy_graph.nodes(`node[type = "subTaxProp"]`).style({
                      'text-wrap': 'wrap',
                      'text-max-width': 230,
                      'border-width': 5,
                      'border-color': '#00008B',
                      'border-style': 'solid',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
                    });
            cy_graph.nodes(`node[type = "overlayRank"]`).style({
              'text-wrap': 'wrap',
              'text-max-width': 150,
              'border-width': 5,
              'border-color': '#228B22',
              'border-style': 'solid',
              'font-size': 35,
              'font-family': 'Calibri',
              'line-height': 1.15
            });
            return subTaxonOf_degree;
      
      
      }

      function create_collapsable_def_box(full_def, cy_graph, num_lines, node_id, prop_node_diam, prop_node_height, old_def) {
          let id_label = `node[id = "${node_id}"]`;
          let new_width = 1000
          
          let new_num_lines = full_def.length/20;
          let def_height = new_num_lines*15 + 50;
          if (full_def.length <= 50) {
            new_width = 500;
          }
          
          let parity_of_tap = 'even';
          let collapsed_node_id = '';

              cy_graph.elements(id_label).on('tap', function(evt) {
                    
                    if (parity_of_tap == 'even') {
                      cy_graph.elements(id_label).style({
                        'background-color': '#ee7600',
                        'width': new_width,
                        'height': def_height,
                        'label': full_def,
                        'text-wrap': 'wrap',
                        'text-max-width': new_width - 20,
                        'border-width': 5,
                        'border-color': '	#ff4d01',
                        'border-style': 'solid',
                        'font-size': 35,
                        'font-family': 'Calibri',
                        'line-height': 1.15

                      });
                      parity_of_tap = 'odd'
                    } else {
                      cy_graph.elements(id_label).style({
                        'background-color': '#FFD580',
                        'width': prop_node_diam,
                        'height': prop_node_height,
                        'label': old_def,
                        'text-wrap': 'wrap',
                        'text-max-width': prop_node_diam - 20,
                        'border-width': 5,
                        'border-color': '#F6BE00',
                        'border-style': 'solid',
                        'font-size': 35,
                        'font-family': 'Calibri',
                        'line-height': 1.15

                        });
                      parity_of_tap = 'even'
                    }
              });
      }

      function box_4_query(json, node_qval, data, cy_graph, 
          pos, pc_edges, prop_node_diam, graphType_pc_edges,
           taxon_qvals, all_ranks, given_taxon, 
           parent_and_all_children, nodes_we_came_from) {
        let prefComparisonList = [];
        let bindings = json.results.bindings;
        //assigning node values to b3 and b4
        //let prefComp_bnode_name = `[`;
       // let rest_prefComp_bnode_name = `[`
        for (let i = 0; i < bindings.length; i++) {
          let comp_value = bindings[i].v2Label;
          if (comp_value != undefined && comp_value.value != 'List' && comp_value.value != 'nil') {
            prefComparisonList.push(comp_value.value); 
          }
        }

        let b4node_names = {full_list: prefComparisonList};
        create_property_nodes(node_qval, data, cy_graph, 
          pos, pc_edges, prop_node_diam, graphType_pc_edges, 
          b4node_names, taxon_qvals, all_ranks, 
          given_taxon, parent_and_all_children, nodes_we_came_from)
      }

      //need this intermediate version because now we have to wait for the result of the b4 query
      function create_property_nodes_intermediate(node_qval, data, cy_graph, 
          pos, pc_edges, prop_node_diam, graphType_pc_edges, taxon_qvals, 
          all_ranks, given_taxon, parent_and_all_children, nodes_we_came_from) {

            let node_name = taxon_qvals[node_qval];
            let url = box_node_query(node_name, true);
              d3.json(url).then(function(json_result) {
                box_4_query(json_result, node_qval, data, cy_graph, 
                   pos, pc_edges, prop_node_diam, graphType_pc_edges, 
                   taxon_qvals, all_ranks, given_taxon,
                    parent_and_all_children, nodes_we_came_from);
              });

      }

      //adds the nodes and edges that resemble the properties for the
      //node with id node_name
      function create_property_nodes(node_qval, data, cy_graph, pos, pc_edges, 
            prop_node_diam, graphType_pc_edges, b4node_names, taxon_qvals, all_ranks,
             given_taxon, parent_and_all_children, nodes_we_came_from) {
            let node_name = taxon_qvals[node_qval]
            let prop_node_height = prop_node_diam;
            let taxon_x_pos = pos.x;
            let taxon_y_pos = pos.y;
            let added_els = [];
            let new_diam = prop_node_diam;
            
            //first want to trim down our redundancy in our query
            let new_prop_data = trim_prop_query(data.results.bindings);

            let bnode_properties = new_prop_data.bnodes_obj;

            let new_property_array = new_prop_data.prop_array;
            let num_property_nodes = new_property_array.length;

            let mult_constant = 10;
            //let mult_constant = prop_node_diam/num_property_nodes;


            //calculate placement of first property node
            //+2 because need to account for adding the subtaxonOf node
            //and the rank node which aren't present in new_property_array.length;
            let circumference = (num_property_nodes + 2) * 50;
            let radius = circumference / (2* Math.PI);
            let curr_degree = 0;
            let degree_movement = (2 * Math.PI) / (num_property_nodes + 2);


            let new_degree = 0;
            let box_nodes = {};

            let assigned_node_type = 'concept';
            let collapse_full_def = 'null';      
            let collapse_node_id = 'null';
            let collapse_num_lines = 0;

            let prop_node_type;
            let prop_node_val;
            let pred_val;
            let num_lines;
            let node_id;
            let image;
            let height;
            let width;
            let next_x_pos;
            let next_y_pos;
            let bnode_props;
            let collapse_diam = prop_node_diam;
            let collapse_height = prop_node_height


            //going to apply the over_lay property to the subtax and rank nodes
            let start_degree = add_subtax_rank_nodes(new_prop_data.subtax_rank, 
                cy_graph, node_qval, radius, mult_constant, prop_node_diam, pos, graphType_pc_edges,
                given_taxon, all_ranks, pc_edges, taxon_qvals, 
                parent_and_all_children, nodes_we_came_from, degree_movement);

            curr_degree = start_degree;

            for (let x = 0; x < num_property_nodes; x++) {
                  new_diam = prop_node_diam;
                  prop_node_type = 'concept';
                  //we want the object label and the predlabel  
                  prop_node_val = new_property_array[x].objLabel ? new_property_array[x].objLabel.value : new_property_array[x].obj.value;
                  pred_val = new_property_array[x].predLabel ? new_property_array[x].predLabel.value : new_property_array[x].pred.value;

                  prop_node_type = new_property_array[x].obj.type;

                  //I define a line to have <= 15 characters 
                  num_lines = Math.ceil((prop_node_val.length)/15);
                  prop_node_height = num_lines * 50 + 50;

                  node_id = prop_node_val;
                  //check to see if it's not already a node on the graph
                  if (pc_edges[prop_node_val] != undefined || 
                      prop_node_val == ROOT_NAME || prop_node_val == node_name) {
                      node_id = prop_node_val.concat(x.toString());
                  }
                  if (prop_node_type == 'literal') {
                      prop_node_val = `"${prop_node_val}"`;
                      assigned_node_type = 'literal';
                      new_diam = 250;}

                  else if (pred_val == "taxonImage") {
                      url_id = prop_node_val
                      image = new Image();
                      // image.crossOrigin = "null";
                      image.src = prop_node_val;
                      image.onload = function() {
                        height = image.naturalHeight;
                        width = image.naturalWidth;
                        cy_graph.$id(url_id).data({
                          'width': width,
                          'height': height
                        }); 
                        cy_graph.$id(url_id).data('href', image.src);
                        cy_graph.$id(url_id).style({
                          'background-image': image.src,
                        });  
                      }
                      assigned_node_type = 'image';
                  } else {
                    //prop_node_type is a concept so we want to ideally get q identifier
                    assigned_node_type = 'concept';
                    prop_node_height = 250;
                    new_diam = 250;
                  }

                  if (pred_val == 'definition') {
                    new_diam = 250;
                    node_id = `${node_id}:def`;
                   // assigned_node_type = 'literall';
                    //If a definition has >=3 lines then we want to implement the collapsable
                    //box feature and change the propnodeval to be something shorter.
                        if (num_lines > 3) {
                          collapse_full_def = prop_node_val;
                          collapse_node_id = node_id;
                          collapse_num_lines = num_lines;
                          
                          //want to slice it at 45 because that's 3 lines
                          prop_node_val = `${prop_node_val.slice(0, 45)} ... \n \ more `;
                          collapse_prop_node_val = prop_node_val;
                        }
                    prop_node_height = 3*50 + 50;
                    assigned_node_type = 'property definition';
                  }

                  if (prop_node_val != undefined) {  

                              new_degree = (curr_degree + degree_movement) % (2 * Math.PI);

                              // case on image here 
                              if (pred_val == "taxonImage") {
                                assigned_node_type = 'image';
                                next_x_pos = taxon_x_pos + (radius*1.8*mult_constant)*(Math.cos(new_degree));
                                next_y_pos = taxon_y_pos - (radius*1.8*mult_constant)*(Math.sin(new_degree));
                                // prop_node_val = '';
                                // cy_graph.nodes('[id = node id]').style(
                                //   { label: new label});
                              }
                              else if (prop_node_type == "bnode") {
                                    new_diam = prop_node_height + 50;
                                    assigned_node_type = 'bnode'
                                    if (new_degree >= ((7/8)*Math.PI) && new_degree <= Math.PI
                                    || new_degree >= Math.PI && new_degree <= (9/8)*Math.PI) {

                                        new_degree = (new_degree + degree_movement) % (2 * Math.PI);

                                    }
                                    next_x_pos = taxon_x_pos + (radius*1.7*mult_constant)*(Math.cos(new_degree));
                                    next_y_pos = taxon_y_pos - (radius*1.7*mult_constant)*(Math.sin(new_degree));
                                    
                                    bnode_props = bnode_properties[prop_node_val];

                                    if (bnode_props.length  >= 2) {
                                        let pred2Label = bnode_props[0].pred2Label;
                                        if (pred2Label != undefined) {
                                          if (pred2Label.value == 'unit') {

                                              let number = bnode_props[1].obj2;
                                              let units = bnode_props[0].obj2Label.value;

                                              prop_node_val = `${prop_node_val}: ${number} ${units}`;
                                          } else {
                                            let prefcomparison = bnode_props[0].obj2Label.value;
                                            prop_node_val = `${prop_node_val}: [${(b4node_names.full_list).join(', ')}]`;
                                          }
                                        }
                                    }
                              } else {
                                
                                
                                if (new_degree <= Math.PI && new_degree >= ((5/6)*Math.PI)
                                || new_degree >= Math.PI && new_degree <= ((7/6)*Math.PI)) {
                                    new_degree = (new_degree + degree_movement) % (2 * Math.PI);
                                } 
                                next_x_pos = taxon_x_pos + (radius*mult_constant)*(Math.cos(new_degree));
                                next_y_pos = taxon_y_pos - (radius*mult_constant)*(Math.sin(new_degree));
                                
                              }
                              curr_degree = new_degree;
                              // position: {x: next_x_pos, y: next_y_pos}
                              // consoloe.log(next_x_pos,next_y_pos)
                              let new_property_node = 
                                {
                                    group: 'nodes',
                                    data: {
                                      id: node_id,
                                      color: '#FFD580',
                                      name: prop_node_val,
                                      opacity: 1,
                                      width: new_diam,
                                      height: prop_node_height,
                                      type: assigned_node_type
                                    },
                                    position: {x: next_x_pos, y: next_y_pos}
                                };
                                if(assigned_node_type == 'property definition') {
                                  collapse_diam = prop_node_diam;
                                  collapse_height = prop_node_height
                                }
                                
                                if (prop_node_type == 'bnode') {
                                  box_nodes[node_id] = (new_property_node);
                                  
                                }
                                added_els.push(new_property_node);
                                // IF it's an image: add href property (most important identifier of the node). add to class of image nodes too
                                
                                let new_edge = 
                                        {
                                          group: 'edges',
                                          data: 
                                              {
                                                  id: node_id.concat(node_qval),
                                                  source: node_qval, 
                                                  target: node_id,
                                                  label: pred_val
                                              }
                                        };

                                  added_els.push(new_edge);
                                  
                    }
                        
              }     

                    cy_graph.add(added_els);

                    let id_label = `[id = '${node_qval}']`


                    let clientWidth = document.getElementById('cy').clientWidth;
                    let clientHeight = document.getElementById('cy').clientHeight;
                    let smaller_space = Math.min(clientWidth, clientHeight);

                    //for num_property_nodes = 9, want clientHeight / 2.17
                    //for num_property_nodes = 6, want clientHeight / 2.4;
                    let padding_amount = Math.floor(clientHeight / 2.3);
                    if (num_property_nodes >= 8) {
                      padding_amount = Math.floor(clientHeight/2.17);
                    }

                    //zoom on the selected node enough to display all of the properties
                    cy_graph.animate({
                      fit: {
                        eles: id_label, 
                        padding: padding_amount
                      }
                    });
                    // IMAGE PROPERTIES
                    let image_id_selector = `node[type = "image"]`;
                    cy_graph.nodes(image_id_selector).style({
                      'shape': 'rectangle',
                      'background-color': 'white',
                      'font-size': 0,
                    });  
                  
                    let literal_id_selector = `node[type = "literal"]`;

                    cy_graph.nodes(literal_id_selector).style({
                      'shape': 'square',
                      'background-color': '#FFD580',
                      'text-wrap': 'wrap',
                      'text-max-width': prop_node_diam - 20,
                      'border-width': 5,
                      'border-color': '#FFA500',
                      'border-style': 'solid',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
                    });

                    let def_id_selector = `node[type = "property definition"]`;

                    cy_graph.nodes(def_id_selector).style({
                      'shape': 'square',
                      'background-color': '#FFD580',
                      'text-wrap': 'wrap',
                      'text-max-width': prop_node_diam - 20,
                      'border-width': 5,
                      'border-color': '#FFA500',
                      'border-style': 'solid',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
                    });

                    let concept_id_selector = `node[type = "concept"]`;

                    cy_graph.nodes(concept_id_selector).style({
                      'background-color': '	#FFB52E',
                      'text-wrap': 'wrap',
                      'text-max-width': prop_node_diam - 20,
                      'border-width': 5,
                      'border-color': '#F6BE00',
                      'border-style': 'solid',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
                    });

                    let bnode_id_selector = `node[type = "bnode"]`;

                    cy_graph.nodes(bnode_id_selector).style({
                      'shape': 'ellipse',
                      'background-color': '#CBC3E3',
                      'text-wrap': 'wrap',
                      'text-max-width': prop_node_diam - 20,
                      'border-width': 5,
                      'border-color': '#301934',
                      'border-style': 'solid',
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
                    });

      
                    cy_graph.elements().edges().style({'font-size': '30'});
                    let parity_dictionary = {}
                    for (const[key, value] of Object.entries(box_nodes)) {

                            let id_label = `node[id = "${key}"]`;
                            parity_dictionary[`parity_of_tap_${key}`] = 'even';  //a way of creating a "new" let for each bnode
                            let all_names = (b4node_names.full_list).join(', ');
                            cy_graph.nodes(id_label).on('tap', function(evt) {
                                  let data = evt.target._private.data;
                                  if (parity_dictionary[`parity_of_tap_${data.id}`] == 'even') {
                                      //bnode_name, box_nodes, bnode_properties, cy_graph
                                      cy_graph.nodes(`[id = "${data.id}"]`).style({
                                        'shape': 'hexagon',
                                        'background-color': '	#fdfa72',
                                        'border-color': '#F6BE00'
                                      });

                                      if (key == 'b3') {
                                            cy_graph.nodes(id_label).style({
                                            'label': `b3`
                                            });
                                      }
                                      add_values_to_bnode(data.id, box_nodes, bnode_properties, 
                                      cy_graph, padding_amount, taxon_x_pos, taxon_y_pos, b4node_names);
                                      parity_dictionary[`parity_of_tap_${data.id}`] = 'odd';
                                      
                                      

                                  } else {
                                      parity_dictionary[`parity_of_tap_${data.id}`] = 'even';

                                      cy_graph.nodes(`[id = "${data.id}"]`).style({
                                        'shape': 'ellipse',
                                        'background-color': '	#CBC3E3',
                                        'border-color': '#301934',
                                        'border-style': 'solid'
                                      });

                                      cy_graph.remove(`node[type = "${data.id} property"]`);
                                      
                                      if (key == 'b3') {
                                          cy_graph.remove( `node[type = "b4 property"]`);
                                          cy_graph.remove(`node[type = "b5 property"]`);
                                            cy_graph.nodes(id_label).style({
                                            'label': `b3: [${all_names}]`
                                            });
                                      }
                                      
                                      
                                  }
                                  
                            }); 

                    }
                    //should only do this if full_def is redefined.
                    if (collapse_full_def != 'null') {
                   
                        create_collapsable_def_box(collapse_full_def, cy_graph, 
                        collapse_num_lines, collapse_node_id, collapse_diam, collapse_height, collapse_prop_node_val);
                    }

          }

              
      function show_property_nodes(node_qval, data, cy_graph, pc_edges, 
      prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, all_ranks, 
      given_taxon, parent_and_all_children, nodes_we_came_from) {
            
            
            let id_label = `[id= '${node_qval}']`;
            let pos = cy_graph.nodes(id_label).position();

            shade_other_nodes(node_qval, cy_graph, id_lastclicked_node);
            create_property_nodes_intermediate(node_qval, data, cy_graph, pos, pc_edges, 
            prop_node_diam, graphType_pc_edges, taxon_qvals, all_ranks, given_taxon, 
            parent_and_all_children, nodes_we_came_from);

      }

      var rank_removal;
      var rank_removed = false;
      //returns the hierarchy back to it's original state
      //after the user unselects a node
      function return_to_normal(node_name, cy_graph, given_taxon, click_of_subtax, farthest_second_left_child_pos) {
            let navDisplayParent = document.getElementById("navigation-history");
            navDisplayParent.innerHTML = "";

            let navButtonsParent = document.getElementById("show-nav-buttons");
            navButtonsParent.innerHTML = "";

            if (!click_of_subtax) {
                //changing the nodes back to their original styles
                  cy_graph.elements().nodes().style( 
                    { 'opacity' : '1',
                      'text-opacity': '1'
                    });

                  //let nodes = cy_graph.elements().nodes();
                  cy_graph.nodes(`node[type = "rank"]`).style({
                            "background-color": "#90EE90",
                            'text-wrap': 'wrap',
                            'text-max-width': 150,
                            'font-size': 35,
                            'font-family': 'Calibri',
                            'line-height': 1.15
                          });
                  cy_graph.nodes(`node[type = "taxon"]`).style({
                            "background-color": "#ADD8E6",
                          });
                          cy_graph.elements().edges().style( 
                            { 'line-opacity' : '1',
                              'text-opacity': '1'
                            });
            }
            

            //changing the edges back to their original styles
            let id_label = `[id = '${node_name}']`;
            cy_graph.nodes(id_label).style("background-color", "#ADD8E6");
            if (click_of_subtax) {
              cy_graph.nodes(id_label).style("opacity", ".2");

            }
            
            id_label = `[id = '${given_taxon}']`;
            cy_graph.nodes(id_label).style("background-color", "red");
            cy_graph.elements().nodes().style({'border-width': '0'});
                  
            cy_graph.remove(`node[type = "subTaxProp"]`);
            cy_graph.remove(`node[type = "overlayRank"]`);
            cy_graph.remove(`node[type = "property"]`);
            cy_graph.remove(`node[type = "concept"]`);
            cy_graph.remove(`node[type = "literal"]`);
            cy_graph.remove(`node[type = "bnode"]`);
            cy_graph.remove(`node[type = "property definition"]`);
            cy_graph.remove(`node[type = "image"]`); 
            cy_graph.remove(`node[type = "rank property"]`);   // remove rank properties   
            cy_graph.remove(`node[type = "rank property edges"]`);   // remove rank properties      
            cy_graph.remove("node[width = 120]"); //removing box nodes
            if (!click_of_subtax) {
                  cy_graph.fit({
                    padding: 19
                  });
                
                cy_graph.animate({
                  zoom: {
                    level: .02,
                    position: {x: farthest_second_left_child_pos.x, y: 0}
                  }
                });
            }
            rank_removal.restore();
            rank_removed = false;
           close_cy2();
      }

      function display_nav_buttons(node_qval, graphType_pc_edges, taxon_qvals, parent_and_all_children) {

        let right_arrow_head_color = 'white';
        let left_arrow_head_color = 'white';
        let down_arrow_head_color = 'white';

        let curr_taxon_name = taxon_qvals[node_qval];

        let middle_nav_width = curr_taxon_name.length/.2;

        
        let curr_parent = graphType_pc_edges[node_qval];
        let curr_parent_name = taxon_qvals[curr_parent];
        let up_arrow_head_color = 'rgb(0, 170, 255)';

        if (curr_parent_name == undefined || curr_parent == 'root') {
          curr_parent_name = " ";
          curr_parent = " ";
          up_arrow_head_color = 'white';
        }
        
        let relationships = ["nav-up", "nav-down", "nav-left", "nav-right"];

        let all_siblings = parent_and_all_children[curr_parent];
        let children = parent_and_all_children[node_qval];
        let left_sibling_name = " ";
        let right_sibling_name = " ";
        let first_child_name = " ";

        let left_sibling = " ";
        let right_sibling = " ";
        let first_child = " ";
        let idx_of_curr_node;



        if (all_siblings != undefined && all_siblings.length > 1) {
          //means there exists other siblings
          idx_of_curr_node = all_siblings.indexOf(node_qval);
          if (idx_of_curr_node > 0) {
              left_sibling = all_siblings[idx_of_curr_node - 1];
              left_sibling_name = taxon_qvals[left_sibling];
              left_arrow_head_color = 'rgb(0, 170, 255)'
          }
          if (idx_of_curr_node < (all_siblings.length - 1)) {
            right_sibling = all_siblings[idx_of_curr_node + 1];
             right_sibling_name = taxon_qvals[right_sibling];
             right_arrow_head_color = 'rgb(0, 170, 255)'
          }
        }

        if (children != undefined && children.length > 0) {
          first_child = children[0];
          first_child_name = taxon_qvals[first_child];
          down_arrow_head_color = 'rgb(0, 170, 255)';
        }
        let arrow_head_colors = [up_arrow_head_color, down_arrow_head_color,
            left_arrow_head_color, right_arrow_head_color];

        let navbuttons = document.getElementById("show-nav-buttons");
            navbuttons.innerHTML = 
            `<div id = "navigation-buttons" style="width: 100%">
              <div style="float:right; text-align: center; margin-right: 70px;">
                  <button id='nav-up' class="nav-buttons" type="button" style="display: inline-block; border-width:0px"> 
                    <span id = 'nav-up-text' style="font-size:15px; color:${up_arrow_head_color}">${curr_parent_name}</span> 
                    <br>
                    <span id = 'nav-up-arrow' style="font-size:15px; color:${up_arrow_head_color}">\u25B2</span> 
                  </button>
  
                  <div style="display:flex">
                    <button id='nav-left' class="nav-buttons" type="button" style="border-width:0px; position: relative; text-align:right">
                      <span id = 'nav-left-arrow' style="font-size:15px; color:${left_arrow_head_color}">${left_sibling_name}    \u25C0</span> 
                    </button>
    
                    <button id="middle-nav" class="nav-buttons" type="button" 
                    style="display: block; font-size: 12px; color:#fff3f4; border-width:0px;">
                    ${curr_taxon_name}
                    </button>
  
                    <button id='nav-right' class="nav-buttons" type="button" style="border-width:0px; position: relative; text-align:left">
                      <span id = 'nav-right-arrow' style="font-size:15px;  color:${right_arrow_head_color}">\u25B6    ${right_sibling_name}</span> 
                    </button>
                   </div>
                  <button id='nav-down' class="nav-buttons" type="button" style="display: inline-block; border-width:0px;"> 
                    <span id = 'nav-down-arrow' style="font-size:15px; color:${down_arrow_head_color}">\u25BC</span> 
                      <br>
                      <span id = 'nav-down-text' style="font-size:15px; color:${down_arrow_head_color}">${first_child_name}</span> 
                    </button>
                  <br>             
              </div>
           </div>`
           
           

           //now we need to add different hover events based on what places we can actually move to
           let idx = 0;
           relationships.forEach(curr_relationship_id => {

              let curr_arrow_color = arrow_head_colors[idx];
              let nav_btn;
              if (curr_arrow_color != 'white') {
                  nav_btn = document.getElementById(curr_relationship_id)
                  nav_btn.addEventListener("mouseover", 
                  function() {
                      document.getElementById(`${curr_relationship_id}-arrow`).style.color = '#00008B';
                      nav_btn.style.backgroundColor = '#D4F1F4';
                      nav_btn.style.borderWidth = "1px";
                      nav_btn.style.borderColor = '#ADD8E6';
                  });
                  nav_btn.addEventListener("mouseout", 
                  function() {
                      document.getElementById(`${curr_relationship_id}-arrow`).style.color = curr_arrow_color;
                      nav_btn.style.backgroundColor = 'white';
                      nav_btn.style.borderWidth = "0px";
                      nav_btn.style.height = '40px';
                  });
              }
              idx += 1;

           })

           //13 has width 150
           //150 = 13*const
           //=>const = 11.5
           //
           const button_size_increase = 11.6
           let new_width;
           if (right_sibling_name.length >= 13){
                new_width = button_size_increase * (right_sibling_name.length);
                document.getElementById("nav-right").style.width = `${new_width}px`;
                document.getElementById("nav-left").style.width = `${new_width}px`;
           }
           if (left_sibling_name.length >= 13){
                new_width = button_size_increase * (left_sibling_name.length);
                document.getElementById("nav-left").style.width = `${new_width}px`;
                document.getElementById("nav-right").style.width = `${new_width}px`;
           }

           return [first_child, left_sibling, right_sibling, curr_parent]
      }

      //only want this function to perform the query if we select a non-rank node
      function get_properties(given_taxon, node_qval, cy_graph, all_ranks,
       pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, 
       parent_and_all_children, nodes_we_came_from) {

            let four_relationships_qvals = display_nav_buttons(node_qval, graphType_pc_edges, taxon_qvals, parent_and_all_children);
            let relationships = ["nav-down", "nav-left", "nav-right", "nav-up"];
            //relationships needs to be in the same order as is returned by the function display nav buttons
            let idx = 0;
            //adding click events for the navigation buttons
            four_relationships_qvals.forEach(qval => {
                let nodes_lst = [];

                let curr_relationship_id = relationships[idx];
                if (curr_relationship_id == "nav-up") {
                  nodes_lst = [...nodes_we_came_from]
                  nodes_lst.push(node_qval);
                } else {
                  nodes_lst = [];
                }
                if (qval != " ") {
                  document.getElementById(`${curr_relationship_id}`).addEventListener('click', function() {
                      get_properties(given_taxon, qval, cy_graph, all_ranks,
                      pc_edges, prop_node_diam, graphType_pc_edges, node_qval, taxon_qvals, parent_and_all_children, nodes_lst)
                  })
                }
                idx +=1;
            });
            

            let curr_parent = graphType_pc_edges[node_qval];
            
            let navDisplayParent = document.getElementById("navigation-history");
            navDisplayParent.innerHTML = "";
            
            let id_label =`[id = '${given_taxon}']`;
              cy_graph.nodes(id_label).style({
                "background-color": "red",
                'border-width': 0
              });
            
            let node_name = taxon_qvals[node_qval];

            cy_graph.remove(`node[type = "subTaxProp"]`);
            cy_graph.remove(`node[type = "overlayRank"]`);
            cy_graph.remove(`node[type = "property"]`);
            cy_graph.remove(`node[type = "concept"]`);
            cy_graph.remove(`node[type = "literal"]`);
            cy_graph.remove(`node[type = "property definition"]`);
            cy_graph.remove(`node[type = "bnode"]`);
            cy_graph.remove(`node[type = "image"]`);
            if (!rank_removed) {
              rank_removal = cy_graph.remove(`node[type = "rank"]`);
              rank_removed = true;
            }
            cy_graph.remove(`node[type = "rank property"]`);   // remove rank properties   
            cy_graph.remove(`node[type = "rank property edges"]`);   // remove rank properties      
            cy_graph.remove("node[width = 120]"); //removing box nodes
            // Restoring previous rank nodes
            
        if (all_ranks.includes(node_name)) {
          return false;
        }

        show_navigation_history(given_taxon, node_qval, cy_graph, all_ranks,
        pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, taxon_qvals, 
        parent_and_all_children, nodes_we_came_from);

        let url = property_query(node_name, true);
          d3.json(url).then(function(json) {
            show_property_nodes(node_qval, json, cy_graph, pc_edges,
             prop_node_diam, graphType_pc_edges, id_lastclicked_node, 
             taxon_qvals, all_ranks, given_taxon, parent_and_all_children, nodes_we_came_from);
          })
      }



      function get_definition(node_name, cy_graph, all_ranks, definitions, definition_node_size) {

          if (all_ranks.includes(node_name)) {
            return false;
          }
          let def_node_height;
          let text_just = 'center';
        
          let taxon_def = definitions[node_name];
          if (taxon_def == undefined || taxon_def == "") {
            taxon_def = "No definition available";
          }

         
          let id_label = `[id = '${node_name}']`;
          let pos = cy_graph.nodes(id_label).position();

          let def_length = taxon_def.length;
          
          let num_lines = Math.ceil(def_length/15);
          let definition_node_height = num_lines*90 + 50;

          let right_shift = 600
          if (num_lines > 3) {
              definition_node_size = 1900
          
              let new_num_lines = def_length/20;
              let definition_node_height = new_num_lines*40 + 50;
              right_shift = 1300
              if (def_length <= 50) {
                definition_node_height = new_num_lines*100 + 100;
                definition_node_size = 500;
                right_shift = 500;
              }
              
          }
          
          if (num_lines > 1) {
            text_just = 'left'
          }

          def_node = {
                              group: 'nodes',
                              data: {
                                id: taxon_def,
                                color: '#FFB6C1',
                                name: taxon_def,
                                opacity: 1,
                                width: definition_node_size,
                                height: definition_node_height,
                                type: 'definition'
                              },
                               position: {x: pos.x + right_shift , y: pos.y}
                          };
          def_edge = {
                            group: 'edges',
                            data: 
                                {
                                    id: taxon_def.concat(node_name),
                                    source: node_name, 
                                    target: taxon_def,
                                    label: 'DEF',
                                }
                          };
          cy_graph.add(def_node);
          cy_graph.add(def_edge);

          let id_selector = `node[width = ${definition_node_size.toString()}]`;
          cy_graph.style().selector(id_selector).style({
            'shape': 'rectangle',
            'text-wrap': 'wrap',
            'text-justification': text_just,
            'text-valign': 'center',
            'text-max-width': definition_node_size - 20,
            'border-width': 5,
            'border-color': '#FF007F',
            'border-style': 'solid',
            'font-size': 75,
            'font-family': 'Calibri',
            'line-height': 1.15

          });
          let edge_id_label = `[id = '${taxon_def.concat(node_name)}']`;
          cy_graph.edges(edge_id_label).style({
            'line-color': '#FF007F',
            'target-arrow-color': '#FF007F',
            'color': 'white',
            'width': 20
          });
          
      }

    
      //when a user is at a node, we want to show the navigation history of a node i.e first want to get it
      //where we can display everything above the node
     function show_navigation_history(given_taxon, node_qval, cy_graph, all_ranks,
        pc_edges, prop_node_diam, graphType_pc_edges, id_lastclicked_node, 
        taxon_qvals, parent_and_all_children, nodes_we_came_from) {


          let prev_nodes_we_came_from = [...nodes_we_came_from];
          let node_ids_above = [];
          let node_names_above = []
          let curr_node = node_qval;
          let curr_node_name = taxon_qvals[node_qval];
          let nodes_above_length = 0;
          let node_id_below;

          //Q2382443 is the q val for Animalia, Q729 is for Animalia

          for (let i = 0; i < nodes_we_came_from.length; i++) {
            node_below_id = nodes_we_came_from[i]
            node_ids_above.push(node_below_id);
            node_names_above.push(taxon_qvals[node_below_id]);
          }

          while (curr_node != ROOT_QVAL || curr_node == undefined) {
            node_ids_above.push(curr_node);
            node_names_above.push(taxon_qvals[curr_node]);
            curr_node = graphType_pc_edges[curr_node];
            nodes_above_length += 1;
          }
          node_names_above.push(ROOT_NAME);
          nodes_above_length +=1;
          node_ids_above.push(ROOT_QVAL);

          //want to add nodes_we_came_from to the displayed list in the navigation history
      

          node_names_above = node_names_above.reverse();
          node_ids_above = node_ids_above.reverse();

          let navDisplayParent = document.getElementById("navigation-history");
          let length = node_names_above.length;
          let nodes_above_text = "";
          let buttonID;
          let idx = 0;
          let curr_button_id = "";
          
          let prev_nodes_we_came_from_length = nodes_we_came_from.length;

          let new_nodes_we_came_from = [...nodes_we_came_from];
          new_nodes_we_came_from.push(node_qval);

          navDisplayParent.style.marginTop = "30px";

          node_names_above.forEach(taxon_name =>{
              
              let node_id = node_ids_above[idx];
              let button = document.createElement("BUTTON");
              button.style.backgroundColor = "white";
              button.style.fontWeight = '550';

              if (node_id == node_qval) {
                if (prev_nodes_we_came_from_length != 0) {

                  button.innerHTML = `${taxon_name} \u25C0`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';

                } else {
                  button.innerHTML = `${taxon_name}`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';
                }
                button.style.color = '#FF69B4';
                button.addEventListener("mouseover", function() {
                button.style.fontWeight = '700';
                button.style.color = ' #AA336A';

              });
              button.addEventListener("mouseout", function() {
                button.style.color = ' #FF69B4';
                button.style.fontWeight = '550';
                button.style.backgroundColor = 'white';
              });

              } else {
                if (idx == node_names_above.length - 1 ) {
                  button.innerHTML = `${taxon_name}`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';

                } else {
                  button.innerHTML = `${taxon_name} \u25C0`;
                  button.style.fontFamily = "Arial";
                  button.style.fontSize = '14px';
                  button.style.textAlign = 'center';
                
                }
                button.style.color = '#03a9f4';
                button.addEventListener("mouseover", function() {
                    button.style.color = ' #03018C';
                    button.style.fontWeight = '700';
                });
              button.addEventListener("mouseout", function() {
                button.style.color = '#03a9f4';
                button.style.fontWeight = '550';
              })

              }


              button.style.borderRadius = "50px";
              curr_button_id = `${taxon_name}-history-display`
              button.id = curr_button_id;
              button.style.border = 0;
              let nodes_lst = [];

              if (idx >= nodes_above_length) {
                    nodes_lst = [];
              }else if (node_id == node_qval) {
                    nodes_lst = prev_nodes_we_came_from;
              } else {
                    nodes_lst = new_nodes_we_came_from;
              }
              button.addEventListener("click", function() {
                      get_properties(given_taxon, node_id, cy_graph, all_ranks,
                      pc_edges, prop_node_diam, graphType_pc_edges, node_qval, taxon_qvals, parent_and_all_children,
                      nodes_lst);
              });
              navDisplayParent.appendChild(button);
              idx += 1;

          })

          
          let cy_container = document.getElementById("cy");
          cy_container.style.height = "65vh";

         

     }

    //  Rank properties for taxon ranks, most notably nextHigher and nextLower rank at the current moment 
    function display_rank_properties(json_result, rank_name, rank_id, cy_graph) {
      let next_higher_rank = "null";
      let next_lower_rank = "null";
      if (json_result.results.bindings.length > 0 &&
          json_result.results.bindings[0].nextHigher != undefined &&
          json_result.results.bindings[0].nextHigher.value != undefined) {
        next_higher_rank = json_result.results.bindings[0].nextHigher.value;
      }

      if (json_result.results.bindings.length > 0 &&
          json_result.results.bindings[0].nextLower != undefined &&
          json_result.results.bindings[0].nextLower.value != undefined) {
        next_lower_rank = json_result.results.bindings[0].nextLower.value;
      }

      //getting position of curr rank node to know relatively where to place the new prop nodes
      let curr_rank_node_pos = cy_graph.nodes(`[id = "${rank_id}"]`).position()
      

      //So now  next_higher_rank and next_lower_rank should be the node names
      //need to make sure the id's are unique since there will be repeats of these
      //the letiable names are null otherwise
      let lower_node = 
            {
                group: 'nodes',
                data: {
                  id: next_lower_rank,
                  color: '#90EE90',
                  name: next_lower_rank,
                  opacity: 1,
                  width: 150,
                  height: 150,
                  type: `rank property`
                },
                position: {x: curr_rank_node_pos['x'] - 400, y: curr_rank_node_pos['y'] + 200}
            };
          cy_graph.add([lower_node]);
      let new_edge = 
            {
              group: 'edges',
              data: 
                  {
                  id: rank_id.concat(next_lower_rank),
                  source: rank_id, 
                  target: next_lower_rank,
                  label: 'nextLowerRank',
                  type: 'rank property edges'
                  }
                };
          cy_graph.add([new_edge]);
      let higher_node = 
            {
                group: 'nodes',
                data: {
                  id: next_higher_rank,
                  color: '#90EE90',
                  name: next_higher_rank,
                  opacity: 1,
                  width: 150,
                  height: 150,
                  type: `rank property`
                },
                position: {x: curr_rank_node_pos['x'] - 400, y: curr_rank_node_pos['y'] - 200}
            };
          cy_graph.add([higher_node]);
      let new_edge1 = 
            {
              group: 'edges',
              data: 
                  {
                  id: rank_id.concat(next_higher_rank),
                  source: rank_id, 
                  target: next_higher_rank,
                  label: 'nextHigherRank',
                  type: 'rank property edges'
                  }
                };
      cy_graph.add([new_edge1]);
      cy_graph.elements().edges().style({'font-size': '30'});

      // Open NEW cy2 container whenever we display such property ranks too. 
      const cy = document.getElementById('cy');
      const cy2 = document.getElementById('cy2');
      cy2.style.display = 'block';
      cy2.style.visibility = 'visible';
      cy.style.height = '97vh';
    }


    function get_rank_property_query(rank_name, rank_id, cy_graph) {
        let url = rank_property_query(rank_name);
        d3.json(url).then(function(json_result) {
        display_rank_properties(json_result, rank_name, rank_id, cy_graph);
      });
    }



    function exec(graphType) {
      let cy_container = document.getElementById("cy");
      cy_container.style.height = "67vh";

      let navDisplayParent = document.getElementById("navigation-history");
      navDisplayParent.innerHTML = "";

      let navButtonsParent = document.getElementById("show-nav-buttons");
      navButtonsParent.innerHTML = "";

      let url = hierarchy_query(ROOT_NAME, true);
      d3.json(url).then(function(json_result) {
        display_hierarchy(json_result, graphType, {given_data: 'null', taxon_value: "null"}, "root");
      });
    }


    //givenData is an object {given_data: 'null'} if we're not going to be given anything, otherwise
    //{given_data: {...}} where {...} is what convert_to_cytoscape(data) would print out
    function display_hierarchy(data, graphType, givenData, given_taxon) {
        console.log(data)
        let user_entered_taxon = givenData.taxon_value;
        let converted_data;

        if (givenData.given_data != 'null') { 
          //this implies we are already given what convert_to_cytoscape would produce
             converted_data = givenData.given_data;
        } else {
             converted_data = convert_to_cytoscape(data);
        }
        console.log(converted_data)
        let root_rank = converted_data.root_rank;
        let root = converted_data.root;
	      let pc_edges = converted_data.pc_edges;
        let definitions = converted_data.definitions;
        let taxon_qvals = converted_data.taxon_qvals;
        let parent_and_all_children = {...(converted_data.parent_and_all_children)};
        //of the form where keys are qvals and values are the taxon names
        let graphType_pc_edges = {...pc_edges};


        let all_ranks = [
        'Subkingdom', 'Phylum', 'Subphylum', 'Infrakingdom', 
        'Superphylum', 'Class', 'Subclass', 'Infraclass', 'Superorder', 
        'Order', 'Suborder', 'Family', 'Genus', 'Species', 'Superfamily', 
        'Subfamily', 'Infraorder', 'Tribe', 'Subgenus', 'Subtribe', 
        'Infraphylum', 'Superclass', 'Kingdom'];

        
        let concise_ranks = [root_rank,
         'Phylum', 'Class', 'Order', 'Family', 
         'Genus', 'Species', 'Tribe', 'Kingdom', 'no_rank'];

        if (graphType == ('Concise')) {
            new_data = create_graphType(converted_data, concise_ranks, user_entered_taxon);
            nodes_lst = new_data.nodes;
            edge_lst = new_data.edges;
            graphType_pc_edges = new_data.newPC_edges;
            parent_and_all_children = {...(new_data.graphType_parent_and_all_children)};

        } else if (graphType == ('Moderate')) {
            new_data = create_graphType(converted_data, all_ranks, user_entered_taxon);
            nodes_lst = new_data.nodes;
            edge_lst = new_data.edges;
            graphType_pc_edges = new_data.newPC_edges;
            parent_and_all_children = {...(new_data.graphType_parent_and_all_children)};

        } else {
          nodes_lst = converted_data.nodes;
          edge_lst = converted_data.edges;
        }

        console.log('graph type parent and all kids in display hierarchy', parent_and_all_children, 'graph type', graphType);

        const cyDiv = document.querySelector('#cy');
        cyDiv.style.display = 'block';        

        let cy = cytoscape({
            container: document.getElementById('cy'),
            elements: {
              nodes: nodes_lst,
              edges: edge_lst
            },
            layout: {
              name: 'dagre', 
              spacingFactor: 4,
              rankDir: 'BT',
              avoidOverlap: true,
            },
            wheelSensitivity: 0.4,
            style: [
                    {
                      selector: 'node[name]',
                        style: {
                            'content': 'data(name)',
                            'text-valign': 'center',

                      }

                  },
                  {
                    selector: 'node',
                    style: {
                      'width': 'data(width)',
                      'height': 'data(height)',
                      'font-size': 30,
                      'background-color': 'data(color)'
                    }

                  },
                  {
                    selector: 'edge',
                    style: {
                        'curve-style': 'bezier',
                        'target-arrow-shape': 'triangle',
                        'label': 'data(label)',
                        'width': 10

                      }
                  },
                  {
                    selector: '.eh-handle',
                      style: {
                        'background-color': 'red',
                        'width': 12,
                        'height': 12,
                        'shape': 'ellipse',
                        'overlay-opacity': 0,
                        'border-width': 12, // makes the handle easier to hit
                        'border-opacity': 0
                      }
                  },
                  {
                    selector: ':selected',
                    style: {
                      "border-width": 2,
                      "border-color": "rgb(1,105,217)"
                    }
                  }
                ]
        });

        // CONTEXT MENU
        let contextMenu = cy.contextMenus({
          menuItems: [
            {
              id: 'copyURL',
              content: 'Copy Image Address',
              selector: 'node[type = "image"]',
              onClickFunction: function (event) {
                let target = event.target;

                navigator.clipboard.writeText(target.data('href'));

                // Tooltip confirmation
                target.popperref = event.target.popper({
                  content: () => {
                    tips.innerHTML = "<p>URL Copied!</p>";
                    tips.style =
                      "background-color: #949494; color: #fff; text-align: left; padding: 2px 4px; border-radius: 3px; font-size:10px;";
                    tips.className = "tooltiptext";
                    document.body.appendChild(tips);
                    setTimeout(function() {
                        document.body.removeChild(tips);
                    }, 1500);
                    return tips;
                  },
                  popper: {
                    placement: "top-start",
                    removeOnDestroy: true
                  }
                })
              },
              hasTrailingDivider: true
            },
            {
              id: 'copyImage',
              content: 'Copy Image',
              tooltipText: 'Copy Image',
              selector: 'node[type = "image"]',
              hasTrailingDivider: true,
              onClickFunction: function (event) {
                let target = event.target;
                let url = target.data('href');
                CopyImageClipboard.copyImageToClipboard(
                  url,
                )
                  .then(() => {
                    console.log('Image Copied')
                  })
                  .catch((e) => {
                    console.log('Error: ', e.message)
                  })
                // Tooltip confirmation
                target.popperref = event.target.popper({
                  content: () => {
                    tips.innerHTML = "<p>Image Copied!</p>";
                    tips.style =
                      "background-color: #949494; color: #fff; text-align: left; padding: 2px 4px; border-radius: 3px; font-size:10px;";
                    tips.className = "tooltiptext";
                    document.body.appendChild(tips);
                    setTimeout(function() {
                        document.body.removeChild(tips);
                    }, 1500);
                    return tips;
                  },
                  popper: {
                    placement: "top-start",
                    removeOnDestroy: true
                  }
                })
              },
            },
            {
              id: 'saveImage',
              content: 'Save image',
              selector: 'node[type = "image"]',
              coreAsWell: true,
              show: true,
              hasTrailingDivider: true,
              onClickFunction: function (event) {
                let target = event.target;
                let url = target.data('href')
                function dataToURL(url) {
                    return fetch(url).then((response) => {
                            return response.blob();
                        }).then(blob => {
                            return URL.createObjectURL(blob);
                        });
                }
                async function downloadImage(url) {
                        const a = document.createElement("a");
                        a.href = await dataToURL(url);
                        a.download = url.split("650px-")[1];
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        console.log("image downloaded!")
                }
                downloadImage(url)
              }
            },
            {
              id: 'newTab',
              content: 'Open Image in New Tab',
              tooltipText: 'Copy Image',
              selector: 'node[type = "image"]',
              hasTrailingDivider: true,
              onClickFunction: function (event) {
                let target = event.target;
                let url = target.data('href');
                window.open(url)
                
                }
              },
          ]
        });

        
        let rank_edges = converted_data.rn_edges;


        let nodes = cy.elements().nodes();

        let rank_node_id;

        let add_eles = [];
        
        for (let x = 0; x < nodes.length; x++) {
            node_pos = nodes[x]._private.position;
            node_id = nodes[x]._private.data.id;
            let x_pos = node_pos.x ;
            let y_pos = node_pos.y;
            let rank_node = rank_edges[node_id];
            if (rank_node != "no_rank") {

                  let rank_node_id = rank_node;
      
                  if (rank_node_id == undefined) {
                    rank_node_id = `noRank ${x.toString()}`;
                  } else {
                    rank_node_id = `${rank_node}: ${x.toString()}`
                  }
                  
                  //rank_node_id is undefined in some places
                  cy.nodes(`node[id="${node_id}"]`).data('rank_id', rank_node_id)
                  new_node = 
                  {
                    group: 'nodes',
                    data: {
                      id: rank_node_id,
                      color: '#90EE90',
                      name: rank_node,
                      width: 100,
                      height: 100,
                      type: 'rank'
                    },
                    position: {x: x_pos - 400, y: y_pos}
                  };
                  
                  add_eles.push(new_node);
      
                  new_edge = 
                      {
                        group: 'edges',
                        data: 
                            {
                                id: node_id.concat(rank_node),
                                source: node_id, 
                                target: rank_node_id,
                                label: 'taxonRank'
                            }
                      };
                  add_eles.push(new_edge);
            }
        }
        //adding ranks to the graph along with edges

          let eles = cy.add(add_eles);
          cy.elements().edges().style({ 'font-size' : '27' });
          cy.elements().nodes().style({
            'font-family': 'Calibri'
          });

          let prop_node_diam = 300
          let definition_node_size = 600
          cy.zoomingEnabled( true );

          let farthest_second_left_child;
          let farthest_second_left_child_pos;

          //maybe make the zoomed position on the given taxon if there is one.
          if (given_taxon != "root") {

            if (parent_and_all_children[given_taxon] == undefined) {
              farthest_second_left_child = given_taxon;
            } else {
              farthest_second_left_child =  (parent_and_all_children[given_taxon])[0];
            }
            farthest_second_left_child_pos = cy.getElementById(`${given_taxon}`).position()
          } else {
            farthest_second_left_child = (parent_and_all_children[(parent_and_all_children[root])[0]])[0]
            farthest_second_left_child_pos = cy.getElementById(`${farthest_second_left_child}`).position()
          }

          let id_label;
          if (given_taxon == "root") {
            id_label = `[id = '${root}']`;
            given_taxon = root;

          } else {
            id_label = `[id = '${given_taxon}']`;
          }
          cy.nodes(id_label).style('background-color', 'red');

          let id_selector = "node[width = 250]";
                    cy.nodes(id_selector).style({
                      'text-wrap': 'wrap',
                      'text-max-width': 150,
                      'font-size': 35,
                      'font-family': 'Calibri',
                      'line-height': 1.15
                    });
      
          
          let zoomedInOnNode = false;
          let id_lastclicked_node = "";

         
          cy.zoom({
            level: .02, // the zoom level
            position: {x: farthest_second_left_child_pos.x, y: 0}
          });


          let prev_nodes_clicked = [];
          let rank_parity_tap = 'even';

          let navDisplayParent = document.getElementById("navigation-history");
            navDisplayParent.innerHTML = "";

          let navButtonsParent = document.getElementById("show-nav-buttons");
            navButtonsParent.innerHTML = "";

          show_navigation_history(given_taxon, given_taxon, cy, all_ranks,
          pc_edges, prop_node_diam, graphType_pc_edges, "", taxon_qvals, 
          parent_and_all_children, []);

          //so we want the functionality of the nav buttons to be different from the one when we are in
          //property display mode
          let four_relationships_qvals = display_nav_buttons(given_taxon, graphType_pc_edges, taxon_qvals, parent_and_all_children);
          let relationships = ["nav-down", "nav-left", "nav-right", "nav-up"];
          //relationships needs to be in the same order as is returned by the function display nav buttons
          let idx = 0;
          //adding click events for the navigation buttons
          four_relationships_qvals.forEach(qval => {
              let nodes_lst = [];

              let curr_relationship_id = relationships[idx];
           
              if (qval != " ") {
                document.getElementById(`${curr_relationship_id}`).addEventListener('click', function() {
                    gethierarchy(qval);
                })
              }
              idx +=1;
          });
          cy.on('tap', function(evt) {
                          
                let evtTarget = evt.target;
                let data = evtTarget._private.data;

                if (Object.keys(data).length == 0) {
                  if (zoomedInOnNode) {
                    return_to_normal(id_lastclicked_node, cy, given_taxon, false, farthest_second_left_child_pos);
                    
                    //when we're not displaying the navigation history we want the display height to go back to normal

                    let cy_container = document.getElementById("cy");
                    cy_container.style.height = "67vh";

                    id_lastclicked_node = "";
                    zoomedInOnNode = false;
                    prev_nodes_clicked = [];
                  }
                } else {
                      //OTHERWISE WE CLICKED A NODE
                        if (data.type == "taxon") {

                          let name = data.name;
                          if (!(all_ranks.includes(name))) {
                              cy.nodes(`node[id = "${data.id}"]`).style({
                                          'width': 250,
                                          'height': 250
                              });
    
                              
                              
                              //only want to add it to prev nodes clicked if we are moving up not to a sibling or down
                              if (id_lastclicked_node != "") {
                                let curr_pos_y = evtTarget._private.position.y
                                let prev_pos_y = cy.nodes(`[id = "${id_lastclicked_node}"]`).position().y
                                if (curr_pos_y < prev_pos_y) {
                                    prev_nodes_clicked.push(id_lastclicked_node);
                                } else {
                                  prev_nodes_clicked = [];
                                }
                              }
                          
                              get_properties(given_taxon, data.id, cy, all_ranks, 
                                      pc_edges, prop_node_diam, graphType_pc_edges, 
                                      id_lastclicked_node, taxon_qvals, parent_and_all_children, prev_nodes_clicked);
                              
    
    
                              zoomedInOnNode = true;
                              id_lastclicked_node = data.id;
                              
                        }
                    }
                    if (data.type == "rank") {
                        
                        //IF A USER CLICKS A RANK WE WANT TO DISPLAY IT'S PROPERTIES
                        //ALSO WANT A WAY TO HIDE THE RANK PROPERTIES WHEN A USER CLICKS ON THE RANK NODE AGAIN
                        //otherwise we clicked a rank node so we want to display the nextHigherRank and nextLowerRank properties
                        let rank_name = data.name;
                        let rank_id = data.id;
                        if (rank_parity_tap == 'even') {
                          get_rank_property_query(rank_name, rank_id, cy);
                          rank_parity_tap = 'odd';
                        } else {
                          cy.remove(`node[type = "rank property"]`);
                          cy.remove(`node[type = "rank property edges"]`);
                          rank_parity_tap = 'even';
                        }
                       

                      }

                     
                    
                    

                }

          })
        
          
          // MOUSEOVER STUFF
          // HOVER NODE: reveal definition 
          cy.nodes().on("mouseover",function(evt) {
                let name = this._private.data.name;
                let style = evt.target._private.style;
                let enlarged_node_size = 275;
                let border_color = '#00008B';
                if ((all_ranks.includes(name))) {
                  enlarged_node_size = 125;
                  border_color = '#013220';
                }

                if (style != undefined) {
                    if (style.opacity == undefined || style.opacity.value == 1) {
                      if (!(all_ranks.includes(name) || name == "Clade")) {
                          get_definition(this.id(), cy, all_ranks, definitions, definition_node_size);
                      }
                    }
                }   
                cy.nodes(`node[id = "${this.id()}"]`).style({
                        'width': enlarged_node_size,
                        'height': enlarged_node_size,
                        'border-width': 1,
                        'border-color': border_color
                });               
            })
          
          .on("mouseout", function(evt) {
            let id_selector = `node[type = "definition"]`;
            cy.remove(id_selector);

            let reg_node_size = 250;
            let name = this._private.data.name;
            if ((all_ranks.includes(name))) {
                reg_node_size = 100
            }
            cy.nodes(`node[id = "${this.id()}"]`).style({
                        'width': reg_node_size,
                        'height': reg_node_size,
                        'border-width': 0,
            });

          });
        
        // Hover over image link: reveal image link 
        let tips = document.createElement("div");
        cy.on('mouseover', 'node[type = "image"]', function(event) {
            let target = event.target;
            target.popperref = event.target.popper({
              content: () => {
                tips.innerHTML = `<a style="color:white;" href='${event.target.data("href")}'>${event.target.data("href")}</a>`;
                tips.style =
                  "background-color: #949494; color: #fff; text-align: left; padding: 6px 8px; border-radius: 4px; font-size:10px;";
                tips.className = "tooltiptext";
                document.body.appendChild(tips);
                return tips;
              },
              popper: {
                placement: "top-start",
                removeOnDestroy: true
              }
            });
          })
          cy.on('mouseout', 'node[type = "image"]', function(event) {           
            tips.style.display = "none";
          });

          // EDGES
          cy.edges().on('mouseover', function(evt) {
            let evtTarget = evt.target;
            let data = evtTarget._private.data;
            cy.edges(`edge[id = "${data.id}"]`).style({
              'arrow-scale': 5
            })
            
          })
          .on('mouseout', function(evt) {
            let evtTarget = evt.target;
            let data = evtTarget._private.data;
            cy.edges(`edge[id = "${data.id}"]`).style({
              'arrow-scale': 1
            })
          })
    }

    function create_cy2(){
      test_nodes = [];
      node_obj1 = {
        data: {id: 'Q34740', 
        name:`Genus boltz:Q34740`,
        color: '#90EE90', 
        width: 250, 
        height: 250,
        type: 'rank'
      }};
      node_obj2 = {
        data: {id: 'Q3238261', 
        name:`Subgenus boltz:Q3238261`,
        color: '#90EE90', 
        width: 250, 
        height: 250,
        type: 'rank'
      }};
      edge_obj = {
        data: {id: `$Q34740 - Q3238261`, 
        source: 'Q34740', 
        target: 'Q3238261', 
        label:'subTaxonOf'
        }};
      let cy2 = cytoscape({
            container: document.getElementById('cy2'),
            elements: {
              nodes: [node_obj1, node_obj2],
              edges: [edge_obj]
            },
            layout: {
              name: 'dagre', 
              spacingFactor: 4,
              rankDir: 'BT',
              avoidOverlap: true,
            },
            style: [
                    {
                      selector: 'node[name]',
                        style: {
                            'content': 'data(name)',
                            'text-valign': 'center',
                      }

                  },
                  {
                    selector: 'node',
                    style: {
                      'width': 10000,
                      'height': 10000,
                      'font-size': 30,
                      'background-color': '#B3767E',
                      'content' : 'data(id)'
                    }

                  },
                  {
                    selector: 'edge',
                    style: {
                        'curve-style': 'bezier',
                        'target-arrow-shape': 'triangle',
                        'label': 'data(label)',
                        'width': 10

                      }
                  },
                  {
                    selector: '.eh-handle',
                      style: {
                        'background-color': 'red',
                        'width': 12,
                        'height': 12,
                        'shape': 'ellipse',
                        'overlay-opacity': 0,
                        'border-width': 12, // makes the handle easier to hit
                        'border-opacity': 0
                      }
                  },
                  {
                    selector: ':selected',
                    style: {
                      "border-width": 2,
                      "border-color": "rgb(1,105,217)"
                    }
                  }
                ]
        });
    }
    function close_cy2() {
      const cy2 = document.getElementById("cy2");
      cy2.style.display = 'none';
      cy2.style.visibility = 'hidden';
    }

      //changes the buttons for the new input node 
      function change_buttons(new_data, full_json, taxonVal) {
            document.getElementById("Full").onclick = 
                  function () {display_hierarchy(full_json, 'Full', {given_data: new_data, taxon_value: taxonVal}, taxonVal)};

            document.getElementById("Moderate").onclick = 
                  function () {display_hierarchy(full_json, 'Moderate', {given_data: new_data, taxon_value: taxonVal}, taxonVal)};

            
            document.getElementById("Concise").onclick = 
                  function () {display_hierarchy(full_json, 'Concise', {given_data: new_data, taxon_value: taxonVal}, taxonVal)};

      }

    /*transform_data is a function that takes in the query from the new root node
    and then updates it so that it returns all the nodes above the queried node*/
    function transform_data(full_data, full_json, short_json, taxonVal, taxon_qval) {
          
          let short_data = convert_to_cytoscape(short_json);
          let short_pc_edges = short_data.pc_edges;
          let pref_labels = full_data.pref_labels;
          let pc_edges = full_data.pc_edges; //grabs the source-target edges so that we can form new edges and add new nodes
          let root = full_data.root;  //in the form of a qval
          let old_nodes = short_data.nodes;
          let names_to_qvals = full_data.names_to_qvals;
          let qvals_to_names = {...full_data.taxon_qvals};
          let given_taxon_parent_and_all_children = {...(short_data.parent_and_all_children)}
          
          let keeping_track_of_new_edges = short_pc_edges;


          let old_edges = short_data.edges;
          let curr_node = taxon_qval; //in the form of a qval 
          let next_node;

          let old_edges_copy = {...old_edges};


          const MAX_ITER = 5000;
          let iterations = 0;
          
          while (curr_node != root && ++iterations < MAX_ITER ) {

            next_node = pc_edges[curr_node];

            next_node_name = `${qvals_to_names[next_node]} boltz: ${next_node}`;

            let new_node = {
              data: {
                  id: next_node, 
                  name: next_node_name, 
                  color: '#ADD8E6', 
                  width: 250, 
                  height: 250,
                  type: 'taxon'
                }};
            old_nodes.push(new_node);
            
            //only add a new edge if it hasn't already been added
            if ((curr_node!= undefined && next_node != undefined)) {
              if (short_pc_edges[curr_node] == undefined || short_pc_edges[curr_node] == "root") {

                if (given_taxon_parent_and_all_children[next_node] == undefined) {
                      given_taxon_parent_and_all_children[next_node] = [curr_node];
                    } else {
                      if (!given_taxon_parent_and_all_children[next_node].includes(curr_node) ) {
                        given_taxon_parent_and_all_children[next_node].push(curr_node);
                      }
                    }

                let new_edge = {data: {id: curr_node.concat(next_node), 
                  source: curr_node, target: next_node, label: 'subTaxonOf'}};
                  old_edges.push(new_edge);

              }
            }

            curr_node = next_node;
          }
          let new_data = {edges: old_edges, nodes: old_nodes, 
            pc_edges: pc_edges, rn_edges: full_data.rn_edges, 
            root_rank: full_data.root_rank, root: full_data.root, 
            definitions: full_data.definitions, taxon_qvals: full_data.taxon_qvals,
            pref_lables: full_data.pref_labels, parent_and_all_children: given_taxon_parent_and_all_children};
          
          //so we've updated our edges and nodes to include the ones above the root we queried, so 
          //now we want to display the graph.

          
          change_buttons(new_data, full_json, taxon_qval);
          display_hierarchy(full_json, 'Concise', {given_data: new_data, taxon_value: taxon_qval}, taxon_qval);
          document.getElementById("Concise").style.background='green';
          document.getElementById("Full").style.background='black';
          document.getElementById("Moderate").style.background='black';



    }


    function change_to_root() {
          hierarchy_query(ROOT_NAME, false);

          document.getElementById("Full").onclick = 
                function () {exec('Full')};
          
          document.getElementById("Moderate").onclick = 
                function () {exec('Moderate')};

          

          document.getElementById("Concise").onclick = 
                function () {exec('Concise')};

          exec('Concise');
          document.getElementById("Concise").style.background='green';
          document.getElementById("Full").style.background='black';
          document.getElementById("Moderate").style.background='black';


          //removing the back to root button because we don't need it
          //if we're already at the root

          let btn = document.getElementById('changetoRoot_button');
          btn.parentNode.removeChild(btn);
          document.getElementById("hierarchySpecies").value = "";
          let el2 = document.getElementById('error_message');
          if (el2 != null) {
            el2.parentNode.removeChild(el2);
          }

    }

    function gethierarchy_intermediate(full_data_json, taxonVal) {
          let full_data = convert_to_cytoscape(full_data_json);

          let pref_labels = full_data.pref_labels;

          let pc_edges = full_data.pc_edges; //grabs the source-target edges so that we can form new edges and add new nodes
          let names_to_qvals = full_data.names_to_qvals;
          let qvals_to_names = full_data.taxon_qvals;


          let pref_label_of_taxonVal = pref_labels[taxonVal];
          let taxon_qval;

          if (qvals_to_names[taxonVal] != undefined){
            taxon_qval = taxonVal;
            taxonVal = qvals_to_names[taxonVal];
          }else{
            taxon_qval = names_to_qvals[taxonVal];
          }

          if (pref_label_of_taxonVal != undefined) {
            //means we are looking at a pref_label of something
            //and we want taxonVal to now be the taxonName
            taxonVal = pref_label_of_taxonVal;
            taxon_qval = names_to_qvals[taxonVal];
          }
      

          if ((taxon_qval == undefined && pref_label_of_taxonVal == undefined)) {
            //now we want to tell the user they have input something invalid
            let place = document.getElementById("hierarchy-entry");
            let error_message = document.createElement("p");
            error_message.innerHTML = `Concept '${taxonVal}' is not found. Please try again.`;
            error_message.id = "error_message";
            place.appendChild(error_message);
            error_message.style.color = 'red';
            return false;
          }
          

          let short_data_url = hierarchy_query(taxonVal, true);

          //change query back to the root one
          hierarchy_query(ROOT_NAME, false);

          d3.json(short_data_url).then(function(short_data_json) {
            transform_data(full_data, full_data_json, short_data_json, taxonVal, taxon_qval);
          })
      }


      function gethierarchy(given_taxon) {
        let navDisplayParent = document.getElementById("navigation-history");
        navDisplayParent.innerHTML = "";
        
        let navButtonsParent = document.getElementById("show-nav-buttons");
        navButtonsParent.innerHTML = "";
        let hierarchyVal;

        if (given_taxon == "null"){
          let el = document.getElementById('changetoRoot_button');
          if (el != null) {
             el.parentNode.removeChild(el);
          }
  
          let el2 = document.getElementById('error_message');
          if (el2 != null) {
            el2.parentNode.removeChild(el2);
          }
  
          let place = document.getElementById("hierarchy-entry");
          let backtoRoot_btn = document.createElement("button");
          backtoRoot_btn.innerHTML = "Back to Root";
          place.appendChild(backtoRoot_btn);
          backtoRoot_btn.setAttribute('id',"changetoRoot_button");
          backtoRoot_btn.style.backgroundColor = 'salmon';
          backtoRoot_btn.style.width = '100px';
          backtoRoot_btn.style.height = '30px';
         /* backtoRoot_btn.setAttribute('style',"width: 100px")
          backtoRoot_btn.setAttribute('style',"height: 30px")*/
  
  
  
          backtoRoot_btn.className = "change-root-button";
          backtoRoot_btn.type = "button";
          backtoRoot_btn.addEventListener('click', function () {
            change_to_root();
          })
  
  
  
          hierarchyVal = document.getElementById("hierarchySpecies").value;
          if (hierarchyVal.length >= 2) {
              hierarchyVal = capitalize(hierarchyVal);
            }
        } else {
          hierarchyVal = given_taxon;
        }
        //check if a "backtoroot" button exists and if it does get rid of it
        let prevquery = document.getElementById("sparql");
        let old_prevquery = prevquery.value;

        //gets the old url
        let endpoint = d3.select("#endpoint").property("value");
        let sparql = d3.select("#sparql").property("value");
        let full_data_url = endpoint + "?query=" + encodeURIComponent(sparql); 
        
          prevquery.innerHTML = old_prevquery;
          document.getElementById("hierarchySpecies").value = "";

          d3.json(full_data_url).then(function(full_data_json) {
            gethierarchy_intermediate(full_data_json, hierarchyVal)
          });
      }


    </script>
  </head>


  <body>


    <div id="query" style="margin: 10px">
      <h1 class = 'title'>Knowledge Graph Query and Display</h1>
        <div class="input-append">
          <input id="endpoint" class="span5" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
          <div id="show-nav-buttons">
          </div>
          
          <div class="graph-type-btns">
            <button id="Full" class="btn" type="button" onclick="exec('Full')">Full</button>
            <button id="Moderate" class="btn" type="button" onclick = "exec('Moderate')">Moderate</button>
            <button id="Concise" class="btn2" type="button" onclick = "exec('Concise')">Concise</button>  
          </div>
         
          <div id ="hierarchy-entry">
            <input id="hierarchySpecies" class="input-species" placeholder="Enter Taxon Name">
          </div>
    
          <div id ="navigation-history" class="nav-history">
          </div>
  
        </div> 
      <textarea id="sparql" class="spans9" style="display:none;"></textarea>

      <input id="endpoint2" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql2" class="spans10" style="display:none;"></textarea>

      <input id="endpoint3" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql3" class="spans10" style="display:none;"></textarea>

      <input id="endpoint4" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql4" class="spans10" style="display:none;"></textarea>

      
    </div>
      <div id="cy">
        <div id="cy2">
          <button id="close_container" class="btn2" type="button" onclick = "close_cy2()">Close Display</button> 
      </div>

      </div>
    </div>

    <script>
      window.onload = exec('Concise');
      let fullButton = document.querySelector('#Full');
      let conciseButton = document.querySelector('#Concise');
      let moderateButton = document.querySelector('#Moderate');


      fullButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = 'green')

      fullButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = '#000000')

      fullButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = '#000000')
      

      conciseButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = 'green')

      conciseButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = '#000000')

      conciseButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = '#000000')


      moderateButton.addEventListener('click', () => 
      moderateButton.style.backgroundColor = 'green')

      moderateButton.addEventListener('click', () => 
      conciseButton.style.backgroundColor = 'black')

      moderateButton.addEventListener('click', () => 
      fullButton.style.backgroundColor = '#000000')
      

      let taxonSpecies = document.getElementById("hierarchySpecies");
        taxonSpecies.addEventListener("keydown", function (e) {
          if (e.key == "Enter") {
            gethierarchy("null");
          }
        });

    </script> 
      
  </body>
</html>
