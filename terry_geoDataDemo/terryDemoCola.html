<!DOCTYPE html>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<html>
  <head>
    <title>Demo for city data</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="../external/d3.v7.min.js"></script>
    <script src="../external/cytoscape.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="https://unpkg.com/webcola/WebCola/cola.min.js"></script>
    <script src="../external/cytoscape-cola/cytoscape-cola.js"></script>
    <script src="js/countyData.js"></script>
    <script src="js/event.js"></script>

    <script>

      
      //later
      // 14. add definitions in ontology files for corporate
      // 15. think about web scrape for other data

      // finally, build the nav bar
      
      //Q: when closing PA, those newly added counties were still there

      //https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States use U.S Bureau source to add region data -> call then divisions


      
      //1. use mycy._private.renderer.imageCache to get image height and width, and style image height width to a reasonable size e.g. fix width = 600 and calculate height (solved)
      //2. re generate normalized center coordinate in countyData.js (solved)
      //3. use the query and algorithm https://github.com/touretzkyds/KnowledgeGraphDemo/issues/59 to generate the correct list (solved)
      

      //TODO:
      // first see how demo2d did with the nav bar
      //4. make the list into buttons. nav history: from right to left / same as animal demo2d / when click on buttons add nodes or open nodes if it already exists
      //5. also do the navigation tool on the top right corner. first think how to nav up and down then sibling
      //6. add regions data according to https://en.wikipedia.org/wiki/List_of_regions_of_the_United_States census bureau
      //7. research about Deya's python file to get data
      
      
      

        var bnodeExpansionDataCache = {};
        var conceptExpansionDataCache = {};
        var conceptNodeLabelToID = {};
        var initialPositions = {};
        var prevImagePositions = {};
        var mycy;

        function propertyQuery(value, perform_query) {
        const prevquery = document.getElementById("sparql");
        prevquery.innerHTML = 
           `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
            PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
            PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
            PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
            PREFIX qudt:  <http://qudt.org/schema/qudt/>
            PREFIX unit:  <http://qudt.org/vocab/unit/> 
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
            PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
            PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
            PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
            PREFIX la: <https://linked.art/ns/terms/>
            PREFIX un: <http://www.w3.org/2007/ont/unit#> 
            PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
            SELECT *
            Where {
            BIND ( '${value}'@en AS ?prefLabel).
            ?Q skos:prefLabel ?prefLabel .
            ?Q ?r ?y.
            OPTIONAL {?Q ?r [?s ?z] FILTER isBlank(?y)}.
            OPTIONAL {?y rdfs:label|skos:prefLabel ?yLabel}.
            }`; 

            
            if (perform_query) {
            const endpoint = d3.select("#endpoint").property("value")
            const sparql = d3.select("#sparql").property("value")
            const url = endpoint + "?query=" + encodeURIComponent(sparql)
            return url
            } else {
            return false
            }

        }

        function propertyQueryWithQnumber(q, perform_query) {
        const prevquery = document.getElementById("sparql");
        prevquery.innerHTML = 
           `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
            PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
            PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
            PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
            PREFIX qudt:  <http://qudt.org/schema/qudt/>
            PREFIX unit:  <http://qudt.org/vocab/unit/> 
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
            PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
            PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
            PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
            PREFIX la: <https://linked.art/ns/terms/>
            PREFIX un: <http://www.w3.org/2007/ont/unit#> 
            PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
            SELECT *
            Where {
            BIND ( '${q}'@en AS ?Q).
            ?Q skos:prefLabel ?prefLabel .
            ?Q ?r ?y.
            OPTIONAL {?Q ?r [?s ?z] FILTER isBlank(?y)}.
            OPTIONAL {?y rdfs:label|skos:prefLabel ?yLabel}.
            }`; 

            
            if (perform_query) {
            const endpoint = d3.select("#endpoint").property("value")
            const sparql = d3.select("#sparql").property("value")
            const url = endpoint + "?query=" + encodeURIComponent(sparql)
            return url
            } else {
            return false
            }

        }

        function navListQuery(value, perform_query) {
          const prevquery = document.getElementById("sparql");
        prevquery.innerHTML = 
           `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
            PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
            PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
            PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
            PREFIX qudt:  <http://qudt.org/schema/qudt/>
            PREFIX unit:  <http://qudt.org/vocab/unit/> 
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
            PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
            PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
            PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
            PREFIX la: <https://linked.art/ns/terms/>
            PREFIX un: <http://www.w3.org/2007/ont/unit#> 
            PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
            SELECT ?xLabel ?yLabel
            WHERE {
              BIND ( '${value}'@en AS ?prefLabel).
              ?Q skos:prefLabel ?prefLabel .
              ?Q kgo:locatedInAdministrativeRegion* ?y.
              ?x kgo:locatedInAdministrativeRegion ?y.
              ?x rdfs:label|skos:prefLabel ?xLabel.
              ?y rdfs:label|skos:prefLabel ?yLabel.
            }`; 

            
            if (perform_query) {
            const endpoint = d3.select("#endpoint").property("value")
            const sparql = d3.select("#sparql").property("value")
            const url = endpoint + "?query=" + encodeURIComponent(sparql)
            return url
            } else {
            return false
            }
        }

        function getRankedNavList(data) {
          const binding = data.results.bindings;
          if(binding.length === 0) {
              return [];
          }
          var pairs = [];
          Object.keys(binding).forEach(function(key) {
            pairs.push(binding[key])
          })
          var nodes = {}
          var done = false
          while(!done) {
            done = true
            for(let i = 0; i < pairs.length; i++) {
              var curr = pairs[i];
              var p = curr.xLabel.value;
              var q = curr.yLabel.value;
              if(!nodes.hasOwnProperty(p)) {
                nodes[p] = 0;
                nodes[q] = 0;
              }
              if(nodes[q] < nodes[p] + 1) {
                nodes[q] = nodes[p] + 1
                done = false
              }
            }
          }
          var navList = [];
          Object.keys(nodes).forEach(function(key) {
            var value = nodes[key];
            var temp = {};
            temp.order = value;
            temp.name = key;
            navList.push(temp);
          })
          navList = navList.sort((a, b) => {
            if (a.order < b.order) {
              return -1;
            }
          }).reverse();
          for(let i = 0; i < navList.length; i++) {
            navList[i] = navList[i].name;
          }
          return navList;
        }

        function appendNavButtons(navList) {
            for(let i = 0; i < navList.length; i++) {
              var name = navList[i];
              var btn = $(`<button class="nav-button">${name} â—€</button>`);
              if(i == navList.length - 1) {
                btn = $(`<button class="nav-button selected">${name}</button>`);
              }
              $("#nav-history").append(btn);
              (function(btn, name) {
                btn.on('click', function(e) {
                  $('.nav-button.selected').removeClass('selected');
                  if(!btn.hasClass("selected")) {
                    btn.addClass("selected")
                  }
                  //TODO: add node function here
                });
              })(btn, name);
            }
         }

        function getDataResponse(value) {
            const url = propertyQuery(value, true);
            conceptNodeLabelToID = {};
            d3.json(url).then(function(data) {visualizeData(data, value);});
            
        }

        function setNavHistoryButtons(cy, value) {
          const navListPairsUrl = navListQuery(value, true);
          d3.json(navListPairsUrl).then(function(data) {appendNavButtons(getRankedNavList(data))});
        }

        function reSetType(cy, id) {
          const idForSourceNode = cy.$("#"+id).json().data.sourceID;
          if(idForSourceNode !== undefined) {
            cy.$("#"+id).json({data:{type: cy.$("#"+idForSourceNode).json().data.type}});
          }
        }

        function classifyclass(key, value) {
          if(key === "image") {
            return "image";
          }
          if(key === "hasCounties") {
            return "countyImage";
          }
          if(value.startsWith('b')) {
            return "qudt";
          }
          if(value.includes('boltz:Q')) {
            return "concept";
          }
          return "literal";
        }

        function reLayoutCola(cy) {
          var layout = cy.layout({
            name: 'cola',
            avoidOverlap: true,
            edgeLength: 500,
            nodeSpacing: 100,
            nodeDimensionsIncludeLabels: true,
            centerGraph:true,
            numIter: 100000,
          });
          
          layout.start();
        }

        function convertToCytoscape(data) {
            if(data === undefined) {
                return undefined;
            }
            var nodes = [];
            var edges = [];
            var source = data.prefLabel.split("boltz:")[1];
            conceptExpansionDataCache[source] = data;
            Object.keys(data).forEach(function(key) {
                var value = data[key];
                var tempNode = {"data":{}};
                tempNode.data.label = value;
                tempNode.data.type = data.type;
                if(key == "prefLabel") {
                  tempNode.data.class = "concept";
                  tempNode.classes = "readyToCollapse";
                  tempNode.data.id = source;
                  conceptNodeLabelToID[value] = source;
                  nodes.push(tempNode);
                } else {
                  tempNode.data.class = classifyclass(key, value);
                  tempNode.data.id = convertToNodeID(source, key, value);
                  tempNode.data.sourceID = source;
                  tempNode.class = "readyToCollapse";
                  if(tempNode.data.class == "concept") {
                    if(!conceptNodeLabelToID.hasOwnProperty(value)) {
                      conceptNodeLabelToID[value] = tempNode.data.id;
                    }
                  }
                  
                  nodes.push(tempNode);

                  var tempEdge = {"data":{}};
                  tempEdge.data.label = key;
                  tempEdge.data.id = convertToEdgeID(source, key);
                  if(value !== source) {
                      tempEdge.data.source = source;
                      tempEdge.data.target = tempNode.data.id;
                      edges.push(tempEdge);
                  }
                }
            })
            return [nodes, edges, source];
        }

        function distanceBetween(x1, y1, x2, y2) {
          return Math.sqrt(Math.pow((x2-x1), 2)+Math.pow((y2-y1),2));
        }

        function getNearestCounty(stateName, normalizedX, normalizedY) {
          var data = countyData[stateName];
          var shortestDistance = Number.MAX_SAFE_INTEGER;
          var nearestCounty = "";
          for(let i = 0; i < data.length; i++) {
            var currCounty = data[i];
            var currDistance = distanceBetween(normalizedX, normalizedY, currCounty.x, currCounty.y);
            if(currDistance < shortestDistance) {
              shortestDistance = currDistance;
              nearestCounty = currCounty.countyName;
            }
          }
          return nearestCounty;
        }

        // get the coordinates of the tap event relative to the node
        function getNormalizedPositions(evt) {
          var node = evt.target;
          var renderedBoundingBox = node.renderedBoundingBox();
          var renderedPosition = evt.renderedPosition;
          var x1 = renderedBoundingBox.x1;
          var x2 = renderedBoundingBox.x2;
          var y1 = renderedBoundingBox.y1;
          var y2 = renderedBoundingBox.y2;
          var x = renderedPosition.x;
          var y = renderedPosition.y;

          var relativeX = x - x1; 
          var relativeY = y - y1;

          var normalizedX = relativeX / (x2 - x1);
          var normalizedY = relativeY / (y2 - y1);
          return {'x': normalizedX, 'y': normalizedY};
        }

        function addCounties(evt, cy) {
          var node = evt.target;
          
          var normalizedX = getNormalizedPositions(evt).x;
          var normalizedY = getNormalizedPositions(evt).y;

          var id = node.json().data.sourceID;

          var stateName = cy.$("#"+id).json().data.label.split("\nboltz:")[0];

          var countyName = getNearestCounty(stateName, normalizedX, normalizedY);
          
          //add new county node
          var addedData = [];
          
          var key = "hasCounty" + countyName.split("\nboltz:")[0];
          var value = countyName;
          var tempNode = {"data":{}};
          tempNode.data.type = "County";
          tempNode.group = "nodes";
          tempNode.data.label = value;
          tempNode.data.class = classifyclass(key, value);
          tempNode.data.id = convertToNodeID(id, key, value);
          tempNode.data.sourceID = id;
          if(tempNode.data.class == "concept") {
            if(!conceptNodeLabelToID.hasOwnProperty(value)) {
              conceptNodeLabelToID[value] = tempNode.data.id;
            } else {
              tempNode.data.class = "dummyConcept";
            }
          }
          const radius = 400; 
          const sourceX = cy.$("#" + id).position('x');
          const sourceY = cy.$("#" + id).position('y');
          tempNode.position = {x:sourceX + radius, y:sourceY - radius};
          addedData.push(tempNode);
          var tempEdge = {"data":{}}
          tempEdge.group = "edges";
          tempEdge.data.id = convertToEdgeID(id, key, value)
          tempEdge.data.label = "hasCounty";
          tempEdge.data.source = id;
          tempEdge.data.target = tempNode.data.id;
          addedData.push(tempEdge);

          cy.add(addedData);
          reLayoutCola(cy);
        }

        function styleImageSize(imgCache, ele, cy) {
          const url = ele.json().data.label;
          const img = imgCache[url].image;
          var imageWidth = img.naturalWidth;
          var imageHeight = img.naturalHeight;
          const maxH = 600;
          const maxW = 600;
          if(imageWidth > maxW) {
            imageWidth = maxW;
            imageHeight = (img.naturalHeight / img.naturalWidth) * imageWidth;
          } else if(imageHeight > maxH) {
            imageHeight = maxW;
            imageWidth = (img.naturalWidth / img.naturalHeight) * imageHeight;
          }
          cy.nodes(`[id = "${ele.id()}"]`).style({
            'width':imageWidth,
            'height':imageHeight,
          });
        }

        function adjustImageSize(cy) {
          cy.nodes().forEach(function( ele ){
            if(ele.json().data.class === 'image' || ele.json().data.class === 'countyImage') {
              const url = ele.json().data.label;
              var imgCache = cy._private.renderer.imageCache;
              if(imgCache === undefined || imgCache[url] === undefined) {
                ele.on('background', function(evt) {
                  imgCache = cy._private.renderer.imageCache;
                  styleImageSize(imgCache, ele, cy);
                });
              } else {
                styleImageSize(imgCache, ele, cy);
              }
            }
          });
        }

        function visualizeData(data, value) {
            const jsonData = getDataJSON(data);
            if(jsonData === undefined) {
              return ;
            }
            const CytoscapeData = convertToCytoscape(jsonData[0]);
            if(CytoscapeData === undefined) {
                return;
            }
            
            const nodes = CytoscapeData[0];
            const edges = CytoscapeData[1];
            const source = CytoscapeData[2];
            
            var cy = cytoscape({
            container: document.getElementById('cy'), // container to render in
            
            elements: {
                nodes: nodes,
                edges: edges
            },
            style: [ // the stylesheet for the graph
            {
                selector: 'node[class = "literal"]',
                style: {
                  'shape': 'square',
                  'width':150,
                  'height': 75,
                  'background-color': '#FFD580',
                  'text-wrap': 'wrap',
                  'text-max-width': 130,
                  'border-width': 2,
                  'border-color': '#FFA500',
                  'border-style': 'solid',
                  'font-size': 15,
                  'font-family': 'Calibri',
                  'line-height': 1.15,
                  'label': 'data(label)',
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "qudt"]',
                style: {
                  'shape': 'hexagon',
                  'width':180,
                  'height':150,
                  'background-color': '	#fdfa72',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'border-width': 2,
                  'border-color': '#F6BE00',
                  'border-style': 'solid',
                  'font-size': 25,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'label': 'data(label)',
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "concept"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#ADD8E6',
                  "border-color": '#00008B',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "dummyConcept"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#FFFFFF',
                  "border-color": '#ADD8E6',
                  "border-width": 10,
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center'
                }
            },
            {
                selector: 'node[class = "greenConcept"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#00FF00',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center'
                }
            },
            {
                selector: 'node[class = "bnode"]',
                style: {
                  'shape': 'ellipse',
                  'border-style': 'solid',
                  'width':120,
                  'height':120,
                  "background-color": '#CBC3E3',
                  "border-color": '#301934',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 30,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "dummy"]',
                style: {
                  'shape': 'ellipse',
                  'border-style': 'solid',
                  'width':100,
                  'height':100,
                  "background-color": 'red',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 30,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "image"]',
                style: {
                  'shape': 'rectangle',
                  'background-image': function(node) {
                    return 'url(' + node.data('label') + ')';
                  },
                  'background-fit': 'cover',
                  'background-color': 'white',
                  'z-index': '10',
                }
            },
            {
                selector: 'node[class = "countyImage"]',
                style: {
                  'shape': 'rectangle',
                  'background-image': function(node) {
                    return 'url(' + node.data('label') + ')';
                  },
                  'background-fit': 'cover',
                  'background-color': 'white',
                  'z-index': '10',
                }
            },
            {
                selector: 'edge',
                style: {
                  'curve-style': 'bezier',
                  'target-arrow-shape': 'triangle',
                  'width': 10,
                  'font-size': 20,
                  'target-arrow-shape': 'triangle',
                  'curve-style': 'bezier',
                  'label': 'data(label)'
                } 
            }
            ]
            });

            setNavHistoryButtons(cy, value)
            
            mycy = cy;
            cy.nodes(`[id = "${source}"]`).style({
                "background-color": 'red'
            });
            reLayoutCola(cy);
            adjustImageSize(cy);

            cy.on('tap', function(evt) {
              tap(evt, cy);
            });
            cy.on('cxttap', function(evt) {
              cxttap(evt, cy);
            });
            cy.on('mouseover', function(evt) {
              mouseover(evt, cy);
            });
            cy.on('mouseout', function(evt) {
              mouseout(evt, cy);
            });
            cy.on('grab', function(evt){
              grab(evt);
            });
            cy.on('drag', function(evt){
              drag(evt);
            });

        }

        function addConceptNode(cy, id, nodeData) {
          // const nodeData = getDataJSON(data);
          conceptExpansionDataCache[id] = nodeData;
          var addedData = [];
          const sourceX = cy.$("#" + id).position('x');
          const sourceY = cy.$("#" + id).position('y');
          const radius = 400;
          var numOfKeys = 0;
          
          Object.keys(nodeData).forEach(function(key) {
            numOfKeys++;
          }) 
          var count = 1;
          cy.$("#"+id).data("type", nodeData.type);
          Object.keys(nodeData).forEach(function(key) {
            if(key != "prefLabel") {
              var value = nodeData[key];

              var tempNode = {"data":{}}
              tempNode.data.type = nodeData.type;
              tempNode.group = "nodes";
              tempNode.data.label = value;
              tempNode.data.class = classifyclass(key, value);
              tempNode.data.id = convertToNodeID(id, key, value);
              tempNode.data.sourceID = id;
              if(tempNode.data.class == "concept") {
                if(!conceptNodeLabelToID.hasOwnProperty(value)) {
                  conceptNodeLabelToID[value] = tempNode.data.id;
                } else {
                  tempNode.data.class = "dummyConcept";
                }
              }
              
              const radian = (Math.PI * 2 / numOfKeys) * count;  
              const x = sourceX + radius * Math.sin(radian);
              const y = sourceY - radius * Math.cos(radian);
              tempNode.position = {x:x, y:y};

              addedData.push(tempNode);
              
              

              var tempEdge = {"data":{}}
              tempEdge.group = "edges";
              tempEdge.data.id = convertToEdgeID(id, key, value)
              tempEdge.data.label = key;
              tempEdge.data.source = id;
              tempEdge.data.target = tempNode.data.id;
              addedData.push(tempEdge);

              cy.add(addedData);
              addedData = [];
              count++;
            }
          })
          reLayoutCola(cy);
          adjustImageSize(cy);
        }

        function removeConceptNode(cy, id) {
          var currNode = cy.$("#"+id);
          //outgoers include both edges and nodes
          var outgoers = currNode.outgoers();
          console.log(edges);
          for(let i = 0; i < outgoers.length; i++) {
            var outgoer = outgoers[i];
            console.log(outgoer);
            if(outgoer.json().group === "edges") {
              cy.remove(outgoer);
            } else if(outgoer.json().group === "nodes") {
              if(outgoer.outgoers().length == 0) {
              const label = outgoer.json().data.label;
              if(conceptNodeLabelToID[label] == outgoer.id()) {
                delete conceptNodeLabelToID[label];
              }
                cy.remove(outgoer);
              }
            }
          }
          reSetType(cy, id);
        }

        function addbNode(cy, id, bnodeData) {
          bnodeExpansionDataCache[id] = bnodeData;
          if(cy.$('#' + id).json().data.label == 'b0') {
            bnodeData = bnodeData.b0;
          } else {
            bnodeData = bnodeData.b1;
          }
          var addedData = [];
          const sourceX = cy.$("#" + id).position('x');
          const sourceY = cy.$("#" + id).position('y');
          const radius = 300;
          var numOfKeys = 1;
          Object.keys(bnodeData).forEach(function(key) {
            numOfKeys++;
          }) 
          var count = 1;
          Object.keys(bnodeData).forEach(function(key) {
            const value = bnodeData[key];
            
            var tempNode = {}
            tempNode.group = "nodes";
            
            const dataID = convertToNodeID(id, key, value);
            tempNode.data = {id: dataID, label: value, class: 'bnode', type: cy.$("#"+id).json().data.type};
            tempNode.data.sourceID = id;
            const radian = (Math.PI * 2 / numOfKeys) * count;  
            const x = sourceX + radius * Math.sin(radian);
            const y = sourceY - radius * Math.cos(radian);
            tempNode.position = {x:x, y:y};

            var tempEdge = {}
            tempEdge.group = "edges";
            tempEdge.data = {id: convertToEdgeID(id, key, value), label: key, source: id, target: dataID};
            addedData.push(tempNode);
            addedData.push(tempEdge);
            cy.add(addedData);
            addedData = [];
            count++;
          })
          reLayoutCola(cy);
        }

        function removebNode(cy, id) {
          var bnodeData = bnodeExpansionDataCache[id];
          if(cy.$('#' + id).json().data.label == 'b0') {
            bnodeData = bnodeData.b0;
          } else {
            bnodeData = bnodeData.b1;
          }
          Object.keys(bnodeData).forEach(function(key) {
            const value = bnodeData[key];
            const nodeID = convertToNodeID(id, key, value);
            const edgeID = convertToEdgeID(id, key, value);
            cy.remove(cy.$('#' + edgeID));
            cy.remove(cy.$('#' + nodeID));
          })
        }

        // note: the case for hasCounty edge is special: the label is hasCounty but the id is hasCounty + county name
        // e.g. hasCountyAllegheny, because otherwise every edge has id 'hasCounty', which leads to duplicates
        function convertToEdgeID(id, key, value) {
          return id + "_" + key;
          // return id + "_" + key + "_" + value;
        }

        function convertToNodeID(id, key, value) {
          return id + "_rel_" + key;
        }

        function getDataJSON(data) {
            const binding = data.results.bindings;
            if(binding.length === 0) {
                alert('Please enter valid name.');
                return undefined;
            }
            var resultData = {};
            var bnodeData = {};
            const prefLabel = binding[0].prefLabel.value;
            const centerQnumber = binding[0].Q.value.split("/data/")[1];
            const prefLabelValue = prefLabel + "\nboltz:" + centerQnumber;
            

            Object.keys(binding).forEach(function(key) {
                const dataEntry = binding[key];
                var relation = dataEntry.r.value;
                if(relation.includes("skos")) {
                  relation = relation.split("core#")[1];
                } else if(relation.includes("rdf")) {
                  relation = relation.split("ns#")[1];
                } else {
                  relation = relation.split("/ontology/")[1]; 
                }
                var finalValue = dataEntry.y.value;
                if(finalValue.startsWith("http://")) {
                  var Qnumber = finalValue.split("/data/")[1];
                  if(Qnumber == undefined) {
                    finalValue = dataEntry.yLabel.value;
                  } else {
                    finalValue = dataEntry.yLabel.value + "\nboltz:" + Qnumber;
                  }
                }
                //store bnode info and add number to node id
                if(dataEntry.y.type == 'bnode') {

                  var bnodeID = finalValue;
                  if(!bnodeData.hasOwnProperty(bnodeID)) {
                    // bnodeExpansionDataCache[bnodeID] = {};
                    bnodeData[bnodeID] = {};
                  }
                  var bnodeKeyList = dataEntry.s.value.split("/");
                  bnodeKey = bnodeKeyList[bnodeKeyList.length - 1];
                  var bnodeValueList = dataEntry.z.value.split("/");
                  bnodeValue = bnodeValueList[bnodeValueList.length - 1];
                  if(bnodeKey.includes("#")) {
                    bnodeKeyList = dataEntry.s.value.split("#");
                    bnodeKey = bnodeKeyList[bnodeKeyList.length - 1];
                  }
                  
                  // bnodeExpansionDataCache[bnodeID][bnodeKey] = bnodeValue;
                  bnodeData[bnodeID][bnodeKey] = bnodeValue;

                }

                if(relation !== "hasCounty") {
                  resultData[relation] = finalValue;
                }
                
            })

            
            resultData["prefLabel"] = prefLabelValue
            return [resultData, bnodeData];
        }
    </script>

  </head>


  <body>


    <div id="query" style="margin: 10px">
      <h1 class="title">Knowledge Graph Query and Display</h1>

        <div class="input-append">
          <div id="show-nav-buttons">
          </div>
          
          <div id ="hierarchy-entry">
            <input id="cityName" class="input-geoData" placeholder="Enter City Name">
          </div>
    
          <div id ="nav-history">
          </div>
  
        </div>
  
      <input id="endpoint" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql" class="spans10" style="display:none;"></textarea>
      
    </div>
    <div id="cy"></div>

    <script>
      const defaultCityName = 'Pittsburgh';
      getDataResponse(defaultCityName);
      $("#cityName").on('keypress',function(e) {
          if(e.which == 13) {
            var cityName = $("#cityName").val()
            getDataResponse(cityName);
          }
      });

    </script> 
      
  </body>
</html>
