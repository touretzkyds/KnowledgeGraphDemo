<!DOCTYPE html>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<html>
  <head>
    <title>Demo for city data</title>
    <script src="external/d3.v7.min.js"></script>
    <script src="external/cytoscape.min.js"></script>

    <script src="external/dagre.js"></script>
    <script src="external/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2/dist/umd/popper.js"></script>
    <script src="external/cytoscape-popper/cytoscape-popper.js"></script>
    <script src="external/cytoscape-context-menus/cytoscape-context-menus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/copy-image-clipboard/dist/index.browser.js"></script>
    <script src="https://unpkg.com/webcola/WebCola/cola.min.js"></script>
    <script src="external/cytoscape-cola/cytoscape-cola.js"></script>
    <script src="newDagre.js"></script>



    <style type="text/css">
      .body{
        margin: 0;
      }

      #cy {
        height: 67vh;
        margin-top:30px;
        width: 100%;
        border-style: solid;
      }

 
      .title {
        text-align: center;
      }
      
      #nav-up,
      #nav-down,
      #nav-left,
      #nav-right{
        border-radius: 50px;
        background-color: white;
        font-weight: 600;
        width: 140px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }
      #southwest-arrow,
      #southeast-arrow{
        background-color: white;
        font-weight: 600;
        border-width: 0px;
        width: 40px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }

      #middle-nav{
        border-radius: 50px;
        background-color: #f08080;
        border: 0px;
        font-weight: 600;
        width: 130px;
        height: 40px;
        text-align: center;
        margin: 2px;
      }
  

      .btn {
        background-color: black;
        color: white;
        padding: 10px;
        width: 100px;
      }



      .btn2 {
        background-color: green;
        color: white;
        padding: 10px;
        width: 100px;
      }

      .input-species {
        background-color: white;
        color: black;
        margin-top: 20px;
        margin-bottom: 20px;
        margin-right: 5px; 
        height: 20px;
        width: 150px;
      }

      .hierarchy-entry-button {
        background-color: white;
        margin-top: 20px;
        margin-bottom: 20px;
        width: 100px; 
        height: 30px;
      }

      .nav-history{
        display: flex;
      }
      
      /* CONTEXT MENUS */
      .cy-context-menus-cxt-menu {
          display:none;
          z-index: 1000;
          position:absolute;
          border:1px solid #A0A0A0;
          padding: 0;
          margin: 0;
          width:auto;
      }

      .cy-context-menus-cxt-menuitem {
          display:block;
          width: 100%;
          padding: 3px 20px;
          position:relative;
          margin:0;
          background-color:#f8f8f8;
          font-weight:normal;
          font-size: 12px;
          white-space:nowrap;
          border: 0;
          text-align: left;
      }

      .cy-context-menus-cxt-menuitem:enabled {
          color: #000000;
      }

      .cy-context-menus-ctx-operation:focus {
        outline: none;
      }

      .cy-context-menus-cxt-menuitem:hover {
          color: #ffffff;
          text-decoration: none;
          background-color: #fdd3ef;
          background-image: none;
          cursor: pointer;
      }

      .cy-context-menus-cxt-menuitem[content]:before {
          content:attr(content);
      }

      .cy-context-menus-divider {
        border-bottom:1px solid #A0A0A0;
      }

      .cy-context-menus-submenu-indicator {
          position: absolute;
          right: 2px;
          top: 50%;
          transform: translateY(-50%);
      }

      
    </style>

    <script>

        var bnodeExpansionDataCache = {};
        var conceptExpansionDataCache = {};
        var conceptNodeLabelToID = {};
        var initialPositions = {};
        // var constraints = [];

        function propertyQuery(value, perform_query) {
        const prevquery = document.getElementById("sparql2");
        prevquery.innerHTML = 
           `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
            PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
            PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
            PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
            PREFIX qudt:  <http://qudt.org/schema/qudt/>
            PREFIX unit:  <http://qudt.org/vocab/unit/> 
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
            PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
            PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
            PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
            PREFIX la: <https://linked.art/ns/terms/>
            PREFIX un: <http://www.w3.org/2007/ont/unit#> 
            PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
            SELECT *
            Where {
            BIND ( '${value}'@en AS ?prefLabel).
            ?Q skos:prefLabel ?prefLabel .
            ?Q ?r ?y.
            OPTIONAL {?Q ?r [?s ?z] FILTER isBlank(?y)}.
            OPTIONAL {?y rdfs:label|skos:prefLabel ?yLabel}.
            }`; 

            
            if (perform_query) {
            const endpoint = d3.select("#endpoint2").property("value")
            const sparql = d3.select("#sparql2").property("value")
            const url = endpoint + "?query=" + encodeURIComponent(sparql)
            return url
            } else {
            return false
            }

        }

        function propertyQueryWithQnumber(q, perform_query) {
        const prevquery = document.getElementById("sparql2");
        prevquery.innerHTML = 
           `PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
            PREFIX kgo: <http://solid.boltz.cs.cmu.edu:3030/ontology/>
            PREFIX boltz: <http://solid.boltz.cs.cmu.edu:3030/data/> 
            PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> 
            PREFIX qudt:  <http://qudt.org/schema/qudt/>
            PREFIX unit:  <http://qudt.org/vocab/unit/> 
            PREFIX xsd: <http://www.w3.org/2001/XMLSchema#> 
            PREFIX list: <http://jena.hpl.hp.com/ARQ/list#> 
            PREFIX qu: <http://purl.oclc.org/NET/ssnx/qu/qu#> 
            PREFIX qud: <http://qudt.org/1.1/schema/qudt#> 
            PREFIX la: <https://linked.art/ns/terms/>
            PREFIX un: <http://www.w3.org/2007/ont/unit#> 
            PREFIX uni: <http://purl.org/weso/uni/uni.html#> 
            SELECT *
            Where {
            BIND ( '${q}'@en AS ?Q).
            ?Q skos:prefLabel ?prefLabel .
            ?Q ?r ?y.
            OPTIONAL {?Q ?r [?s ?z] FILTER isBlank(?y)}.
            OPTIONAL {?y rdfs:label|skos:prefLabel ?yLabel}.
            }`; 

            
            if (perform_query) {
            const endpoint = d3.select("#endpoint2").property("value")
            const sparql = d3.select("#sparql2").property("value")
            const url = endpoint + "?query=" + encodeURIComponent(sparql)
            return url
            } else {
            return false
            }

        }

        function getDataResponse(value) {
            const url = propertyQuery(value, true);
            conceptNodeLabelToID = {};
            d3.json(url).then(function(data) {visualizeData(data);});
        }

        function classifyclass(value) {
          if(value.startsWith('b')) {
            return "qudt";
          }
          if(value.includes('boltz:Q')) {
            return "concept";
          }
          return "literal";
        }

        function convertToCytoscape(data) {
            if(data === undefined) {
                return undefined;
            }
            var nodes = [];
            var edges = [];
            var source = data.prefLabel.split("boltz:")[1];
            conceptExpansionDataCache[source] = data;
            //how the id is defined?
            //node: if it's not a concept: <boltzQnumber of the source>_to_<relationship>
            // if it's a concept: <boltzQnumber>
            //edge: <boltzQnumber of the source>_<relations>
            Object.keys(data).forEach(function(key) {
                var value = data[key];
                var tempNode = {"data":{}};
                tempNode.data.label = value;
                tempNode.data.type = data.type;
                if(key == "prefLabel") {
                  tempNode.data.class = "center";
                  tempNode.classes = "readyToCollapse";
                  tempNode.data.id = source;
                  conceptNodeLabelToID[value] = source;
                  // tempNode.data.type = data.type;
                  nodes.push(tempNode);
                } else {
                  tempNode.data.class = classifyclass(value);
                  tempNode.data.id = convertToNodeID(source, key, value);
                  tempNode.data.sourceID = source;
                  if(tempNode.data.class == "concept") {
                    if(!conceptNodeLabelToID.hasOwnProperty(value)) {
                      conceptNodeLabelToID[value] = tempNode.data.id;
                    }
                  }

                
                  // tempNode.data.id = convertToNodeID(source, key, value);
                  
                  nodes.push(tempNode);

                  var tempEdge = {"data":{}};
                  tempEdge.data.label = key;
                  tempEdge.data.id = convertToEdgeID(source, key);
                  if(value !== source) {
                      tempEdge.data.source = source;
                      tempEdge.data.target = tempNode.data.id;
                      edges.push(tempEdge);
                  }
                }
            })
            // push dummy nodes to split canvas
            const p = 1500;
            const factor = 5;
            var tempNode1 = {"data":{}};
            tempNode1.position = {x:0, y:0};
            tempNode1.data.id = "d1";
            tempNode1.data.label = "d1"; 
            tempNode1.data.class = "dummy"; 

            var tempNode2 = {"data":{}};
            tempNode2.position = {x:factor*p, y:0};
            tempNode2.data.id = "d2";
            tempNode2.data.label = "d2"; 
            tempNode2.data.class = "dummy"; 

            var tempNode3 = {"data":{}};
            tempNode3.position = {x:0, y:p};
            tempNode3.data.id = "d3";
            tempNode3.data.label = "d3"; 
            tempNode3.data.class = "dummy"; 

            var tempNode4 = {"data":{}};
            tempNode4.position = {x:factor*p, y:p};
            tempNode4.data.id = "d4";
            tempNode4.data.label = "d4"; 
            tempNode4.data.class = "dummy"; 

            var tempNode5 = {"data":{}};
            tempNode5.position = {x:0, y:2*p};
            tempNode5.data.id = "d5";
            tempNode5.data.label = "d5"; 
            tempNode5.data.class = "dummy"; 

            var tempNode6 = {"data":{}};
            tempNode6.position = {x:factor*p, y:2*p};
            tempNode6.data.id = "d6";
            tempNode6.data.label = "d6"; 
            tempNode6.data.class = "dummy"; 

            var tempNode7 = {"data":{}};
            tempNode7.position = {x:0, y:3*p};
            tempNode7.data.id = "d7";
            tempNode7.data.label = "d7"; 
            tempNode7.data.class = "dummy"; 

            var tempNode8 = {"data":{}};
            tempNode8.position = {x:factor*p, y:3*p};
            tempNode8.data.id = "d8";
            tempNode8.data.label = "d8"; 
            tempNode8.data.class = "dummy"; 

            nodes.push(tempNode1);
            nodes.push(tempNode2);
            nodes.push(tempNode3);
            nodes.push(tempNode4);
            nodes.push(tempNode5);
            nodes.push(tempNode6);
            nodes.push(tempNode7);
            nodes.push(tempNode8);
            return [nodes, edges];
        }

        function reLayoutCola(cy) {
          var constraints = []
          const idArray = ["d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8"]
          const gap = 500;
          cy.nodes().forEach(function(ele){
            if(!idArray.includes(ele.id())) {
              if(ele.json().data.type == "State") {
                constraints.push({ axis: 'x', left: cy.$("#d1"), right: ele, gap: gap });
                constraints.push({ axis: 'y', left: cy.$("#d1"), right: ele, gap: gap });
                constraints.push({ axis: 'x', left: ele, right: cy.$("#d4"), gap: gap });
                constraints.push({ axis: 'y', left: ele, right: cy.$("#d4"), gap: gap });

                // constraints.push({ axis: 'x', left: cy.$("#d3"), right: ele, gap: gap });
                // constraints.push({ axis: 'y', left: cy.$("#d3"), right: ele, gap: gap });
                // constraints.push({ axis: 'x', left: ele, right: cy.$("#d2"), gap: gap });
                // constraints.push({ axis: 'y', left: ele, right: cy.$("#d2"), gap: gap });
              } else if(ele.json().data.type == "County") {
                constraints.push({ axis: 'x', left: cy.$("#d3"), right: ele, gap: gap });
                constraints.push({ axis: 'y', left: cy.$("#d3"), right: ele, gap: gap });
                constraints.push({ axis: 'x', left: ele, right: cy.$("#d6"), gap: gap });
                constraints.push({ axis: 'y', left: ele, right: cy.$("#d6"), gap: gap });

                // constraints.push({ axis: 'x', left: cy.$("#d5"), right: ele, gap: gap });
                // constraints.push({ axis: 'y', left: cy.$("#d5"), right: ele, gap: gap });
                // constraints.push({ axis: 'x', left: ele, right: cy.$("#d4"), gap: gap });
                // constraints.push({ axis: 'y', left: ele, right: cy.$("#d4"), gap: gap });
              } else {
                console.log(ele.id());
                constraints.push({ axis: 'x', left: cy.$("#d5"), right: ele, gap: gap });
                constraints.push({ axis: 'y', left: cy.$("#d5"), right: ele, gap: gap });
                constraints.push({ axis: 'x', left: ele, right: cy.$("#d8"), gap: gap });
                constraints.push({ axis: 'y', left: ele, right: cy.$("#d8"), gap: gap });

                // constraints.push({ axis: 'x', left: cy.$("#d7"), right: ele, gap: gap });
                // constraints.push({ axis: 'y', left: cy.$("#d7"), right: ele, gap: gap });
                // constraints.push({ axis: 'x', left: ele, right: cy.$("#d6"), gap: gap });
                // constraints.push({ axis: 'y', left: ele, right: cy.$("#d6"), gap: gap });
              }
            }
          });
          var layout = cy.layout({
            name: 'cola',
            avoidOverlap: true,
            edgeLength: 500,
            nodeSpacing: 100,
            nodeDimensionsIncludeLabels: true,
            centerGraph:true,
            gapInequalities: constraints,
            numIter: 100000,
          });
          
          layout.start();
        }

        function reSetType(cy, id) {
          const idForSourceNode = cy.$("#"+id).json().data.sourceID;
          cy.$("#"+id).json({data:{type: cy.$("#"+idForSourceNode).json().data.type}});
        }

        function visualizeData(data) {
            const CytoscapeData = convertToCytoscape(getDataJSON(data)[0]);
            if(CytoscapeData === undefined) {
                return;
            }
            
            const nodes = CytoscapeData[0];
            const edges = CytoscapeData[1];
            var cy = cytoscape({
            container: document.getElementById('cy'), // container to render in
            
            elements: {
                nodes: nodes,
                edges: edges
            },
            style: [ // the stylesheet for the graph
            {
                selector: 'node[class = "literal"]',
                style: {
                  'shape': 'square',
                  'width':150,
                  'height': 75,
                  'background-color': '#FFD580',
                  'text-wrap': 'wrap',
                  'text-max-width': 130,
                  'border-width': 2,
                  'border-color': '#FFA500',
                  'border-style': 'solid',
                  'font-size': 15,
                  'font-family': 'Calibri',
                  'line-height': 1.15,
                  'label': 'data(label)',
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "qudt"]',
                style: {
                  'shape': 'hexagon',
                  'width':180,
                  'height':150,
                  'background-color': '	#fdfa72',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'border-width': 2,
                  'border-color': '#F6BE00',
                  'border-style': 'solid',
                  'font-size': 25,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'label': 'data(label)',
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "concept"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#ADD8E6',
                  "border-color": '#00008B',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "dummyConcept"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#FFFFFF',
                  "border-color": '#ADD8E6',
                  "border-width": 10,
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center'
                }
            },
            {
                selector: 'node[class = "greenConcept"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#00FF00',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center'
                }
            },
            {
                selector: 'node[class = "greenCenter"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": '#00FF00',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center'
                }
            },
            {
                selector: 'node[class = "center"]',
                style: {
                  'width':150,
                  'height':150,
                  "background-color": 'red',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 20,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "bnode"]',
                style: {
                  'shape': 'ellipse',
                  'border-style': 'solid',
                  'width':120,
                  'height':120,
                  "background-color": '#CBC3E3',
                  "border-color": '#301934',
                  'text-wrap': 'wrap',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 30,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'node[class = "dummy"]',
                style: {
                  'shape': 'ellipse',
                  'border-style': 'solid',
                  'width':100,
                  'height':100,
                  "background-color": 'red',
                  'text-max-width': 80,
                  'label': 'data(label)',
                  'font-size': 30,
                  'font-family': 'Garamond',
                  'line-height': 1.15,
                  'text-valign': 'center',
                }
            },
            {
                selector: 'edge',
                style: {
                  'curve-style': 'bezier',
                  'target-arrow-shape': 'triangle',
                  'width': 10,
                  'font-size': 20,
                  'target-arrow-shape': 'triangle',
                  'curve-style': 'bezier',
                  'label': 'data(label)'
                } 
            }
            ]
            ,
            layout: {
              name: 'cola',
              avoidOverlap: true,
              edgeLength: 500,
              nodeSpacing: 100,
              nodeDimensionsIncludeLabels: true,
              centerGraph:true,
            } 
            });
            cy.on('tap', function(evt) {
              var node = evt.target;
              if(node.json().data.class === 'qudt') {
                if(!cy.$("#" + node.id()).hasClass('readyToCollapse')) {
                  const sourceQnumber = cy.$('#' + node.json().data.sourceID).json().data.label.split("boltz:")[1];
                  const bnodeID = sourceQnumber + "_rel_" + node.json().data.label;
                  const sourceCityName = cy.$('#' + node.json().data.sourceID).json().data.label.split("\nboltz:")[0];
                    if(bnodeExpansionDataCache.hasOwnProperty(node.id())) {
                      addbNode(cy, node.id(), bnodeExpansionDataCache[node.id()]);
                    } else {
                      const url = propertyQuery(sourceCityName, true);
                      d3.json(url).then(function(data) {addbNode(cy, node.id(), getDataJSON(data)[1]);});
                    }
                  
                  cy.$("#" + node.id()).addClass('readyToCollapse');
                } else {
                  const sourceQnumber = cy.$('#' + node.json().data.sourceID).json().data.label.split("boltz:")[1];
                  const bnodeID = sourceQnumber + "_rel_" + node.json().data.label;
                  removebNode(cy, node.id());
                  cy.$("#" + node.id()).removeClass('readyToCollapse');
                  
                }
              } else if(node.json().data.class === 'dummyConcept') {
                const id = conceptNodeLabelToID[node.json().data.label];
                cy.center("#" + id);
              } else if(node.json().data.class === 'concept') {
                const cityName = node.json().data.label.split("\nboltz")[0]
                if(!cy.$("#" + node.id()).hasClass('readyToCollapse')) {
                  cy.center("#" + node.id());
                  if(conceptExpansionDataCache.hasOwnProperty(node.id())) {
                    addConceptNode(cy, node.id(), conceptExpansionDataCache[node.id()]);
                  } else {
                    const url = propertyQuery(cityName, true);
                    d3.json(url).then(function(data) {addConceptNode(cy, node.id(), getDataJSON(data)[0]);});
                  }

                  cy.$("#" + node.id()).addClass('readyToCollapse');
                } else {
                  cy.$("#" + node.id()).removeClass('readyToCollapse');
                  removeConceptNode(cy, node.id());
                }
              }
            });
            cy.on('cxttap', function(evt) {
              var node = evt.target;
              if(node.json().data.class === 'dummyConcept') {
                cy.nodes(`[id = "${node.id()}"]`).style({
                    'width': node.width() * 1.25,
                    'height': node.height() * 1.25
                });

                const id = conceptNodeLabelToID[node.json().data.label];
                if(id !== undefined) {
                  cy.nodes(`[id = "${id}"]`).style({
                    'width': cy.$('#'+id).width() * 0.8,
                    'height': cy.$('#'+id).height() * 0.8
                  });
                  if(cy.$("#" + id).json().data.class === 'greenCenter') {
                    cy.$("#"+id).json({data:{class:'center'}});
                  } else if(cy.$("#" + id).json().data.class === 'greenConcept') {
                    cy.$("#"+id).json({data:{class:'concept'}});
                  }
                }
                

                const currlabel = node.json().data.label;
                cy.nodes().forEach(function( ele ){
                  if(ele.json().data.label === currlabel && (ele.json().data.class === 'concept' || ele.json().data.class === 'center')) {
                    ele.json({data:{class:'dummyConcept'}});
                  }
                });
                node.json({data:{class:'concept'}});
                conceptNodeLabelToID[node.json().data.label] = node.id();

                if(id !== undefined) {
                  if(cy.$("#" + id).hasClass('readyToCollapse')) {
                    removeConceptNode(cy, id);
                    cy.$("#" + id).removeClass('readyToCollapse');
                  }
                }
                
              }
              
            });
            cy.on('mouseover', function(evt) {
              var node = evt.target;
              if(node.json().data.class === 'qudt' || node.json().data.class === 'concept') {
                cy.nodes(`[id = "${node.id()}"]`).style({
                    'width': node.width() * 1.25,
                    'height': node.height() * 1.25
                });
              } else if(node.json().data.class === 'dummyConcept') {
                const id = conceptNodeLabelToID[node.json().data.label];
                if(id !== undefined) {
                  cy.nodes(`[id = "${conceptNodeLabelToID[node.json().data.label]}"]`).style({
                      'width': cy.$('#'+id).width() * 1.25,
                      'height': cy.$('#'+id).height() * 1.25,
                  });
                  if(cy.$("#" + id).json().data.class === 'center') {
                    cy.$("#"+id).json({data:{class:'greenCenter'}});
                  } else if(cy.$("#" + id).json().data.class === 'concept') {
                    cy.$("#"+id).json({data:{class:'greenConcept'}});
                  }
                }
              }
            });
            cy.on('mouseout', function(evt) {
              var node = evt.target;
              if(node.json().data.class === 'qudt' || node.json().data.class === 'concept') {
                cy.nodes(`[id = "${node.id()}"]`).style({
                    'width': node.width() * 0.8,
                    'height': node.height() * 0.8
                });
              } else if(node.json().data.class === 'dummyConcept') {
                const id = conceptNodeLabelToID[node.json().data.label];
                cy.nodes(`[id = "${id}"]`).style({
                  'width': cy.$('#'+id).width() * 0.8,
                  'height': cy.$('#'+id).height() * 0.8,
                });
                if(cy.$("#" + id).json().data.class === 'greenCenter') {
                  cy.$("#"+id).json({data:{class:'center'}});
                } else if(cy.$("#" + id).json().data.class === 'greenConcept') {
                  cy.$("#"+id).json({data:{class:'concept'}});
                }
              }
            });
            cy.on('grab', function(evt){
              var draggedNode = evt.target;
              initialPositions[draggedNode.id()] = {
                x: draggedNode.position('x'),
                y: draggedNode.position('y')
              };
              var connectedNodes = draggedNode.neighborhood();
              connectedNodes.forEach(function(node){
                if(node.id() !== draggedNode.id()){
                  initialPositions[node.id()] = {
                    x: node.position('x'),
                    y: node.position('y')
                  };
                }
              });
            });
            cy.on('drag', function(evt){
              var draggedNode = evt.target;
              var connectedNodes = draggedNode.neighborhood();
              connectedNodes.forEach(function(node){
                if(node.id() !== draggedNode.id() && node.outgoers().length == 0){
                  var dx = draggedNode.position('x') - initialPositions[draggedNode.id()].x; 
                  var dy = draggedNode.position('y') - initialPositions[draggedNode.id()].y; 
                  var newX = dx + initialPositions[node.id()].x;
                  var newY = dy + initialPositions[node.id()].y;
                  node.position({
                    x: newX,
                    y: newY
                  });
                }
              });
            });

            cy.$("#d1").lock();
            cy.$("#d2").lock();
            cy.$("#d3").lock();
            cy.$("#d4").lock();
            cy.$("#d5").lock();
            cy.$("#d6").lock();
            cy.$("#d7").lock();
            cy.$("#d8").lock();
            // reLayoutCola(cy);
        }

        function addConceptNode(cy, id, nodeData) {
          // const nodeData = getDataJSON(data);
          conceptExpansionDataCache[id] = nodeData;
          var addedData = [];
          const sourceX = cy.$("#" + id).position('x');
          const sourceY = cy.$("#" + id).position('y');
          const radius = 400;
          var numOfKeys = 0;
          
          Object.keys(nodeData).forEach(function(key) {
            numOfKeys++;
          }) 
          var count = 1;
          cy.$("#"+id).data("type", nodeData.type);
          Object.keys(nodeData).forEach(function(key) {
            if(key != "prefLabel") {
              var value = nodeData[key];

              var tempNode = {"data":{}}
              tempNode.data.type = nodeData.type;
              tempNode.group = "nodes";
              tempNode.data.label = value;
              tempNode.data.class = classifyclass(value);
              tempNode.data.id = convertToNodeID(id, key, value);
              tempNode.data.sourceID = id;
              if(tempNode.data.class == "concept") {
                if(!conceptNodeLabelToID.hasOwnProperty(value)) {
                conceptNodeLabelToID[value] = tempNode.data.id;
              } else {
                tempNode.data.class = "dummyConcept";
              }
              }
              
              const radian = (Math.PI * 2 / numOfKeys) * count;  
              const x = sourceX + radius * Math.sin(radian);
              const y = sourceY - radius * Math.cos(radian);
              tempNode.position = {x:x, y:y};

              addedData.push(tempNode);
              
              

              var tempEdge = {"data":{}}
              tempEdge.group = "edges";
              tempEdge.data.id = convertToEdgeID(id, key)
              tempEdge.data.label = key;
              tempEdge.data.source = id;
              tempEdge.data.target = tempNode.data.id;
              addedData.push(tempEdge);

              cy.add(addedData);
              addedData = [];
              count++;
            }
          })
          reLayoutCola(cy);
        }

        function removeConceptNode(cy, id) {
          const nodeData = conceptExpansionDataCache[id];
          Object.keys(nodeData).forEach(function(key) {
            if(key != "prefLabel") {
              var value = nodeData[key];
              const nodeID = convertToNodeID(id, key, value);
              const edgeID = convertToEdgeID(id, key);
              if(cy.$('#' + nodeID).outgoers().length == 0) {
                const label = cy.$('#' + nodeID).json().data.label;
                if(conceptNodeLabelToID[label] == nodeID) {
                  delete conceptNodeLabelToID[label];
                }
                cy.remove(cy.$('#' + edgeID));
                cy.remove(cy.$('#' + nodeID));
              }
            }
          })
          reSetType(cy, id);
          // reLayout(cy);
        }

        function removeConceptNodeExceptConcept(cy, id) {
          const nodeData = conceptExpansionDataCache[id];
          Object.keys(nodeData).forEach(function(key) {
            if(key != "prefLabel") {
              var value = nodeData[key];
              const nodeID = convertToNodeID(id, key, value);
              const edgeID = convertToEdgeID(id, key);
              if(cy.$('#' + nodeID).json().data.class != "concept") {
                cy.remove(cy.$('#' + edgeID));
                cy.remove(cy.$('#' + nodeID));
              }
            }
            // conceptNodeLabelToID
          })
          reSetType(cy, id);
          // reLayout(cy);
        }

        function addbNode(cy, id, bnodeData) {
          bnodeExpansionDataCache[id] = bnodeData;
          if(cy.$('#' + id).json().data.label == 'b0') {
            bnodeData = bnodeData.b0;
          } else {
            bnodeData = bnodeData.b1;
          }
          var addedData = [];
          const sourceX = cy.$("#" + id).position('x');
          const sourceY = cy.$("#" + id).position('y');
          const radius = 300;
          var numOfKeys = 1;
          Object.keys(bnodeData).forEach(function(key) {
            numOfKeys++;
          }) 
          var count = 1;
          Object.keys(bnodeData).forEach(function(key) {
            const value = bnodeData[key];
            
            var tempNode = {}
            tempNode.group = "nodes";
            
            const dataID = convertToNodeID(id, key, value);
            tempNode.data = {id: dataID, label: value, class: 'bnode', type: cy.$("#"+id).json().data.type};
            tempNode.data.sourceID = id;
            const radian = (Math.PI * 2 / numOfKeys) * count;  
            const x = sourceX + radius * Math.sin(radian);
            const y = sourceY - radius * Math.cos(radian);
            tempNode.position = {x:x, y:y};

            var tempEdge = {}
            tempEdge.group = "edges";
            tempEdge.data = {id: convertToEdgeID(id, key), label: key, source: id, target: dataID};
            addedData.push(tempNode);
            addedData.push(tempEdge);
            cy.add(addedData);
            addedData = [];
            count++;
          })
          reLayoutCola(cy);
        }

        function removebNode(cy, id) {
          var bnodeData = bnodeExpansionDataCache[id];
          if(cy.$('#' + id).json().data.label == 'b0') {
            bnodeData = bnodeData.b0;
          } else {
            bnodeData = bnodeData.b1;
          }
          Object.keys(bnodeData).forEach(function(key) {
            const value = bnodeData[key];
            const nodeID = convertToNodeID(id, key, value);
            const edgeID = convertToEdgeID(id, key);
            cy.remove(cy.$('#' + edgeID));
            cy.remove(cy.$('#' + nodeID));
          })
        }

        function convertToEdgeID(id, key) {
          return id + "_" + key;
        }

        function convertToNodeID(id, key, value) {
          // if(classifyclass(value) == "concept") {
          //   value = value.split("boltz:")[1];
          //   return value;
          // } else 
          if(classifyclass(value) == "qudt") {
            return id + "_rel_" + value;
          }
          return id + "_rel_" + key;
        }

        function getDataJSON(data) {
            const binding = data.results.bindings;
            if(binding.length === 0) {
                alert('Please enter valid name.');
                return undefined;
            }
            var resultData = {};
            var bnodeData = {};
            const prefLabel = binding[0].prefLabel.value;
            const centerQnumber = binding[0].Q.value.split("/data/")[1];
            const prefLabelValue = prefLabel + "\nboltz:" + centerQnumber;
            

            Object.keys(binding).forEach(function(key) {
                const dataEntry = binding[key];
                var relation = dataEntry.r.value;
                if(relation.includes("skos")) {
                  relation = relation.split("core#")[1];
                } else if(relation.includes("rdf")) {
                  relation = relation.split("ns#")[1];
                } else {
                  relation = relation.split("/ontology/")[1]; 
                }
                var finalValue = dataEntry.y.value;
                if(finalValue.startsWith("http://")) {
                  var Qnumber = finalValue.split("/data/")[1];
                  if(Qnumber == undefined) {
                    finalValue = dataEntry.yLabel.value;
                  } else {
                    finalValue = dataEntry.yLabel.value + "\nboltz:" + Qnumber;
                  }
                }
                //store bnode info and add number to node id
                if(dataEntry.y.type == 'bnode') {

                  var bnodeID = finalValue;
                  if(!bnodeData.hasOwnProperty(bnodeID)) {
                    // bnodeExpansionDataCache[bnodeID] = {};
                    bnodeData[bnodeID] = {};
                  }
                  var bnodeKeyList = dataEntry.s.value.split("/");
                  bnodeKey = bnodeKeyList[bnodeKeyList.length - 1];
                  var bnodeValueList = dataEntry.z.value.split("/");
                  bnodeValue = bnodeValueList[bnodeValueList.length - 1];
                  if(bnodeKey.includes("#")) {
                    bnodeKeyList = dataEntry.s.value.split("#");
                    bnodeKey = bnodeKeyList[bnodeKeyList.length - 1];
                  }
                  
                  // bnodeExpansionDataCache[bnodeID][bnodeKey] = bnodeValue;
                  bnodeData[bnodeID][bnodeKey] = bnodeValue;

                }

                resultData[relation] = finalValue;
            })

            
            resultData["prefLabel"] = prefLabelValue
            return [resultData, bnodeData];
        }
    </script>

  </head>


  <body>


    <div id="query" style="margin: 10px">
      <h1 class="title">Knowledge Graph Query and Display</h1>

        <div class="input-append">
        
          <input id="endpoint" class="span5" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
          <div id="show-nav-buttons">
          </div>
          
          <div id ="hierarchy-entry">
            <input id="cityName" class="input-species" placeholder="Enter City Name">
          </div>
    
          <div id ="navigation-history" class="nav-history">
            
          </div>
  
        </div>
        
      <textarea id="sparql" class="spans9" style="display:none;"></textarea>

      <input id="endpoint2" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql2" class="spans10" style="display:none;"></textarea>

      <input id="endpoint3" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql3" class="spans10" style="display:none;"></textarea>

      <input id="endpoint4" class="span6" value="https://solid.boltz.cs.cmu.edu:3031/Devel/sparql" type="text" style="display:none;">
      <textarea id="sparql4" class="spans10" style="display:none;"></textarea>

      
    </div>
    <div id="cy"></div>

    <script>
      const defaultCityName = 'Pittsburgh';
      getDataResponse(defaultCityName);
        let cityName = document.getElementById("cityName");
        cityName.addEventListener("keypress", function (e) {
            if (e.key == "Enter") {
                getDataResponse(cityName.value);
            }
        });

    </script> 
      
  </body>
</html>
